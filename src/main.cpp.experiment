#include <string>
#include <fstream>
#include <vector>
#include <map>
#include <stack>
#include <algorithm>
#include <cstring>
#include <cstdlib>
#include <cmath>
#include <time.h>
#include <pthread.h>
#include <json/json.h>


#define MAX_STRING_LEN 100
#define EXP_TABLE_SIZE 1000
#define MAX_EXP 6
#define PI 3.14159265358979323846


typedef float real;

/**hyper parameters for training**/
int thread_num = 1;
int iter = 100;
int vector_dim = 40;
real learn_rate_pv = 0.00;//0.01
real learn_rate_r = 0.00;
real learn_rate_r_rel = 0.00;
real gama_pv = 0.5;//for text training
real gama_r = 1;//for transE

bool learn_pv = false;
bool learn_relation = false;

int min_word_reduce = 1;

char run_type[MAX_STRING_LEN];
char pv_input_file[MAX_STRING_LEN];
char triplet_input_file[MAX_STRING_LEN];
char model_dir[MAX_STRING_LEN];
char model_file[MAX_STRING_LEN];
char similarity_test_file[MAX_STRING_LEN];
char relation_test_file[MAX_STRING_LEN];
char topn_output[MAX_STRING_LEN];
char wordvec_output_file[MAX_STRING_LEN];
char wordvec_input_file[MAX_STRING_LEN];
char model_file_pv[MAX_STRING_LEN];
char model_file_word[MAX_STRING_LEN];


real *exp_table;
std::vector<int> shuffle_vec;

const int max_entry_size = 6000000;     // Maximum 6M entries
const int entry_hash_size = 12000000;   // Maximum 12M, hash size is two times of entry size in case of two many hash crash

const int max_word_size = 1000000;       // Maximum 30K words
const int word_hash_size = 2000000;      // Maximum 60K

/**statistic infomation**/
int entry_size = 0;
int word_size = 0;
int rel_size = 0;

struct Id_Score_Rank {
    int id;
    real score;
    int rank;
};

bool compareScore(Id_Score_Rank a, Id_Score_Rank b) {
    return a.score > b.score;
}
bool compareId(Id_Score_Rank a, Id_Score_Rank b) {
    return a.id < b.id;
}
/**store the entry infomation**/
struct entry {
    char *entry_name;
    std::vector<int> word_list;
    int word_num;
};

/** store word information **/
struct word_info {
    char *word;
    int count;
};

// array to store the infomation of each entry
struct entry *entry_array;

// array to store the infomation of ea
struct word_info *word_array;

std::vector<int> word_negative_list;
// save the pos of each entry in entry array
int *entry_hash;

// save the pos of each word in word array
int *word_hash;



/**struct for traverse the graph**/
struct stack_element {
    int index;
    //indicate how many children or parents have been visited
    int visit_num;
};

// vector of entries
real *entry_vec;

// vector of words
real *word_vec;

// vector of relations
real *relation_vec;

// relation transform matrix
real *transform;

// save relation map
std::map<std::string,int> rel2id;
std::map<int,std::string> id2rel;

struct Triple {
    int lid;
    int relid;
    int rid;
};

std::vector<Triple> triplet;
std::vector<Triple> testtriple;
struct TestData_Sim {
    std::vector<int> leftindex;
    std::vector<int> rightindex;
    real score;
};

struct TestData_WordSim {
    int leftindex;
    int rightindex;
    real score;
};

std::vector<TestData_Sim> test_array_sim;
std::vector<TestData_WordSim> test_array_wordsim;
void split(const std::string& src, const std::string& separator, std::vector<std::string>& dest) {
    std::string str=src;
    std::string substring;
    std::string::size_type start=0,index;

    do
    {
        index=str.find_first_of(separator,start);
        if(index!=std::string::npos)
        {
            substring= str.substr(start,index-start);
            dest.push_back(substring);
            start = str.find_first_not_of(separator,index);
            if (start == std::string::npos) return;
        }
    }while(index != std::string::npos);
    substring=str.substr(start);
    dest.push_back(substring);
}




unsigned int get_entry_hash(const char *entry_name) {
    unsigned long long hash = 1;
    int str_len = strlen(entry_name);
    for (int i = 0; i < str_len; i++) hash = hash * 257 + entry_name[i];
    hash = hash % entry_hash_size;
    return hash;
}

unsigned int get_word_hash(const char *word) {
    unsigned long long hash = 1;
    int str_len = strlen(word);
    for (int i = 0; i < str_len; i++) hash = hash * 257 + word[i];
    hash = hash % word_hash_size;
    return hash;
}

unsigned int get_insert_entry_hash(const char *entry_name) {
    unsigned int hash = get_entry_hash(entry_name);
    while (-1 != entry_hash[hash]) {
        hash = (hash + 1) % entry_hash_size;
    }
    return hash;
}

unsigned int get_insert_word_hash(const char *word) {
    unsigned int hash = get_word_hash(word);
    while (-1 != word_hash[hash]) {
        hash = (hash + 1) % word_hash_size;
    }
    return hash;
}

int search_entry(const char *entry_name) {
    unsigned int hash = get_entry_hash(entry_name);
    while (1) {
        if (entry_hash[hash] == -1) return -1;
        if (!strcmp(entry_name, entry_array[entry_hash[hash]].entry_name)) return hash;
        hash = (hash + 1) % entry_hash_size;
    }
}

int search_word(const char *word) {
    unsigned int hash = get_word_hash(word);
    while (1) {
        if (word_hash[hash] == -1) return -1;
        if (!strcmp(word, word_array[word_hash[hash]].word)) return hash;
        hash = (hash + 1) % word_hash_size;
    }
}

void reduce_vocab() {
    int hash = -1;
    int count = 0;
    for (int i = 0; i < word_size; i++) {
        if (word_array[i].count > min_word_reduce) {
            word_array[count].count = word_array[i].count;
            word_array[count].word = word_array[i].word;
            count++;
        } else {
            free(word_array[i].word);
        }
    }
    word_size = count;
    std::cout << "reduced vocab size: " << word_size << std::endl;    

    for (int i = 0; i < word_hash_size; i++) {
        word_hash[i] = -1;
    }

    for (int i = 0; i < word_size; i++) {
        hash = get_word_hash(word_array[i].word);
        while (word_hash[hash] != -1) hash = (hash + 1) % word_hash_size;
        word_hash[hash] = i;
    }
    if (min_word_reduce < 15) min_word_reduce++;
}

void load_triplet(const char *filepath) {
    std::ifstream fin(filepath);
    std::string line;
    int hash, leftid, rightid, relid;
    while(getline(fin, line)) {
        std::vector<std::string> l;
        split(line,"\t",l);
        
        hash = search_entry(l[0].c_str());
        if (-1 == hash) {
            leftid = entry_size;
            hash = get_insert_entry_hash(l[0].c_str());
            entry_hash[hash] = entry_size;
            
            entry_array[entry_size].entry_name = (char *)calloc(l[0].length() + 1, sizeof(char));
            strcpy(entry_array[entry_size].entry_name, l[0].c_str());
            entry_array[entry_size].entry_name[l[0].size()] = '\0';
            entry_size++;
            if (entry_size % 1000 == 0) std::cout << "entry size: " << entry_size << std::endl;
        }
        else {
            leftid = entry_hash[hash];
        }
        
        hash = search_entry(l[2].c_str());
        if (-1 == hash) {
            rightid = entry_size;
            hash = get_insert_entry_hash(l[2].c_str());
            entry_hash[hash] = entry_size;
            
            entry_array[entry_size].entry_name = (char *)calloc(l[2].length() + 1, sizeof(char));
            strcpy(entry_array[entry_size].entry_name, l[2].c_str());
            entry_array[entry_size].entry_name[l[2].size()] = '\0';
            entry_size++;
            if (entry_size % 1000 == 0) std::cout << "entry size: " << entry_size << std::endl;
        }
        else {
            rightid = entry_hash[hash];
        }
        
        if(rel2id.find(l[1])==rel2id.end())
        {
                relid=rel2id.size();
                rel2id.insert(std::pair<std::string,int>(l[1],relid));
                id2rel.insert(std::pair<int,std::string>(relid,l[1]));
        }
        else
            relid=rel2id[l[1]];
            
        Triple trip = {leftid, relid, rightid};
        triplet.push_back(trip);
    }
    std::random_shuffle(triplet.begin(), triplet.end());
    rel_size = rel2id.size();
}
// parse the json format entry_info, and add this entry, for load subgraph file
// assume the links and categories all in the subgraph
void add_entry_paragraph(const std::string &entry_info) {
        std::vector<std::string> l;
        split(entry_info,"\t",l);
        std::string entry_name = l[0];
		
        
        
        int hash = search_entry(entry_name.c_str());
        int entry_name_hash = -1;
        //std::cout<<entry_name<<" "<<hash<<std::endl;
        if (-1 == hash) {
            entry_name_hash = get_insert_entry_hash(entry_name.c_str());
            // save entity name to entry array
            entry_array[entry_size].entry_name = (char *)calloc(entry_name.length() + 1, sizeof(char));
            strcpy(entry_array[entry_size].entry_name, entry_name.c_str());
            entry_array[entry_size].entry_name[entry_name.size()] = '\0';
            entry_hash[entry_name_hash] = entry_size;
            entry_size++;
            if (entry_size % 1000 == 0) std::cout << "entry size: " << entry_size << std::endl;
        } else {
            entry_name_hash = hash;
        }
		if(l.size()>1){ 
			std::vector<std::string> paragraph;
			split(l[1]," ",paragraph);
		
			int wordhash = -1;
			//entry_array[entry_hash[entry_name_hash]].word_list = (int *)calloc(paragraph.size(), sizeof(int));
			for (unsigned int i = 0; i < paragraph.size(); i++) {
				std::string word = paragraph[i];
				wordhash = search_word(word.c_str());
				if (-1 != wordhash) {
					word_array[word_hash[wordhash]].count++;
				} else {
					wordhash = get_insert_word_hash(word.c_str());
					word_array[word_size].word = (char *)calloc(word.length() + 1, sizeof(char));
					strcpy(word_array[word_size].word, word.c_str());
					word_array[word_size].word[word.size()] = '\0';
					word_array[word_size].count = 1;
					word_hash[wordhash] = word_size;                
					word_size++; 
				}
				entry_array[entry_hash[entry_name_hash]].word_list.push_back(word_hash[wordhash]);
			}
			entry_array[entry_hash[entry_name_hash]].word_num = paragraph.size();
		} else {
			entry_array[entry_hash[entry_name_hash]].word_num = 0;
		}
}

void load_wordlist(const char *filename) {
	std::ifstream inStm(filename);
	std::string line; 
	getline(inStm, line);
    while (getline(inStm, line)) {
        std::vector<std::string> l;
        split(line," ",l);
        std::string word = l[0];
        int wordhash = get_insert_word_hash(word.c_str());
        word_array[word_size].word = (char *)calloc(word.length() + 1, sizeof(char));
        strcpy(word_array[word_size].word, word.c_str());
        word_array[word_size].word[word.size()] = '\0';
        word_array[word_size].count = 1;
		word_hash[wordhash] = word_size;                
        word_size++; 
    }
}


void load_entry_paragraph(const char *file_path) {
    std::ifstream inStm(file_path);
    std::string line; 
    int num = 0;
    while (getline(inStm, line)) {
        // std::cout << line << std::endl;
        add_entry_paragraph(line);
        num++;
        if (num % 100000 == 0) {
            std::cout << "load_entry_paragraph, line_num: " << num << std::endl;
        }
    }
    for (int i = 0; i < word_size; ++i) {
        for (int j = 0; j < (int)sqrt((real)word_array[i].count); ++j) word_negative_list.push_back(i);
    }
    std::cout << "total entry num: " << entry_size << std::endl;
    inStm.close();
}

        
// init entry vector, entity and category have the same dimension
void init_vector() {
    
    posix_memalign((void **)&entry_vec, 128, (long long)entry_size * vector_dim * sizeof(real));
    if (NULL == entry_vec) std::cerr << "memory allocation fail for entry_vec." << std::endl;
    posix_memalign((void **)&word_vec, 128, (long long)word_size * vector_dim * sizeof(real));
    if (NULL == word_vec) std::cerr << "memory allocation fail for word_vec." << std::endl;
    posix_memalign((void **)&relation_vec, 128, (long long)rel_size * vector_dim * sizeof(real));
    if (NULL == relation_vec) std::cerr << "memory allocation fail for relation_vec." << std::endl;
    posix_memalign((void **)&transform, 128, (long long)rel_size * vector_dim * vector_dim * sizeof(real));
    if (NULL == transform) std::cerr << "memory allocation fail for transform." << std::endl;
    // randomize the entry vector
    /**/
    unsigned long long next_random = 1;
    for (int i = 0; i < entry_size; i++) {
		real sum = 0;
		for (int j = 0; j < vector_dim; j++) {
			next_random = next_random * (unsigned long long)25214903917 + 11;
            entry_vec[i * vector_dim + j] = (((next_random & 0xFFFF) / (real)65536) - 0.5) / vector_dim;
			//entry_vec[i * vector_dim + j] = ((real)rand()/RAND_MAX-0.5)*2*6/sqrt((real)vector_dim);
			sum += entry_vec[i * vector_dim + j] * entry_vec[i * vector_dim + j];
		}
		for (int j = 0; j < vector_dim; j++) entry_vec[i * vector_dim + j] /= sqrt(sum);
    }
    
    for (int i = 0; i < word_size; i++) for (int j = 0; j < vector_dim; j++) {
        next_random = next_random * (unsigned long long)25214903917 + 11;
        word_vec[i * vector_dim + j] = (((next_random & 0xFFFF) / (real)65536) - 0.5) / vector_dim;
    }
    
    for (int i = 0; i < rel_size; i++) {
        real sum = 0;
        for (int j = 0; j < vector_dim; j++) {
            //next_random = next_random * (unsigned long long)25214903917 + 11;
            //relation_vec[i * vector_dim + j] = (((next_random & 0xFFFF) / (real)65536) - 0.5) / vector_dim;
			relation_vec[i * vector_dim + j] = ((real)rand()/RAND_MAX-0.5)*2*6/sqrt((real)vector_dim);
            sum += relation_vec[i * vector_dim + j] * relation_vec[i * vector_dim + j];
        }
        for (int j = 0; j < vector_dim; j++) relation_vec[i * vector_dim + j] /= sqrt(sum);
    }
    
    for (int i = 0; i < rel_size; ++i) {
        for (int j = 0; j < vector_dim; ++j) {
            for (int k = 0; k < vector_dim; ++k) {
                if (j == k) transform[i * vector_dim * vector_dim + j * vector_dim + k] = 1;
                else 
                    transform[i * vector_dim * vector_dim + j * vector_dim + k] = 0;
            }
        }
    }

}

inline real multiply(real *x, real *y, int dim) {
    real res = 0.0;
    for (int i = 0; i < dim; ++i) res += x[i] * y[i];
    return res;
}

void normalization(real *vector, int dim) {
    real norm = 0;
    for (int i = 0; i < dim; ++i) norm += vector[i] * vector[i];
    norm=sqrt(norm);
    for (int i = 0; i < dim; ++i) vector[i]/=norm;
}

inline real get_exp_inner(real *x, real *y, int dim) {
    real res = 0.0;
    for (int i = 0; i < dim; i++) {
        res += x[i] * y[i];
    }
    if (res >= MAX_EXP) {
        res = MAX_EXP;
    } else if (res <= -MAX_EXP) {
        res = -MAX_EXP;
    }
    return exp_table[(int)((res + MAX_EXP) * (EXP_TABLE_SIZE / MAX_EXP / 2))];   
}

void update_embedding_paragraph(int entry_id, real &cost, real &word_num) {
    //bzero(input_ent_gradient, vector_dim * sizeof(real));
    real *input_ent_gradient = (real *)calloc(vector_dim, sizeof(real));
    
    word_num += 30 > entry_array[entry_id].word_num ? entry_array[entry_id].word_num : 30;
	std::random_shuffle(entry_array[entry_id].word_list.begin(),entry_array[entry_id].word_list.end());
	int samplesize = 30 > entry_array[entry_id].word_num ? entry_array[entry_id].word_num : 30;
    for (int i = 0; i < samplesize; ++i) {
        int wid = entry_array[entry_id].word_list[i];
        int corrupt_wid = word_negative_list[rand() % word_negative_list.size()];

        real cost_tmp = gama_pv - multiply(&word_vec[wid * vector_dim], &entry_vec[entry_id * vector_dim], vector_dim) \
                  + multiply(&word_vec[corrupt_wid * vector_dim], &entry_vec[entry_id * vector_dim], vector_dim);

        if (cost_tmp > 0) {
            cost += cost_tmp;
            for (int j = 0; j < vector_dim; j++) {
                input_ent_gradient[j] += -word_vec[wid * vector_dim + j] + word_vec[corrupt_wid * vector_dim + j];
                word_vec[wid * vector_dim + j] -= -learn_rate_pv * entry_vec[entry_id * vector_dim + j];
                word_vec[corrupt_wid * vector_dim + j] -= learn_rate_pv * entry_vec[entry_id * vector_dim + j];
            }
        }
    }

    for (int j = 0; j < vector_dim; ++j) {
        entry_vec[entry_id * vector_dim + j] -= learn_rate_pv * input_ent_gradient[j];
    }
    free(input_ent_gradient);
}

void update_embedding_paragraph_withwordfix(int entry_id, real &cost, real &word_num){
	real *input_ent_gradient = (real *)calloc(vector_dim, sizeof(real));
    
    word_num += 30 > entry_array[entry_id].word_num ? entry_array[entry_id].word_num : 30;
	std::random_shuffle(entry_array[entry_id].word_list.begin(),entry_array[entry_id].word_list.end());
	int samplesize = 30 > entry_array[entry_id].word_num ? entry_array[entry_id].word_num : 30;
    for (int i = 0; i < samplesize; ++i) {
        int wid = entry_array[entry_id].word_list[i];
        int corrupt_wid = word_negative_list[rand() % word_negative_list.size()];

        real cost_tmp = gama_pv - multiply(&word_vec[wid * vector_dim], &entry_vec[entry_id * vector_dim], vector_dim) \
                  + multiply(&word_vec[corrupt_wid * vector_dim], &entry_vec[entry_id * vector_dim], vector_dim);

        if (cost_tmp > 0) {
            cost += cost_tmp;
            for (int j = 0; j < vector_dim; j++) {
                input_ent_gradient[j] += -word_vec[wid * vector_dim + j] + word_vec[corrupt_wid * vector_dim + j];
            }
        }
    }

    for (int j = 0; j < vector_dim; ++j) {
        entry_vec[entry_id * vector_dim + j] -= learn_rate_pv * input_ent_gradient[j];
    }
    free(input_ent_gradient);
}

void update_embedding_relation_unstructure(std::vector<Triple> &thread_triplet, real &cost) {
	int count_train=0;
    for(unsigned int i = 0; i < thread_triplet.size(); ++i) {
        int lid = thread_triplet[i].lid;
        int rid = thread_triplet[i].rid;
        int corrupt_lid, corrupt_rid;
        if(rand()%2 == 0) {
            corrupt_lid = rand()%entry_size;
            corrupt_rid = rid;
        } else {
            corrupt_lid = lid;
            corrupt_rid = rand()%entry_size;
        }
        real *left_embedding = entry_vec + lid * vector_dim;
        real *right_embedding = entry_vec + rid * vector_dim;
        real *corrupt_left_embedding = entry_vec + corrupt_lid * vector_dim;
        real *corrupt_right_embedding = entry_vec + corrupt_rid * vector_dim;
        
        real cost_tmp = 1 \
        - multiply(left_embedding, right_embedding, vector_dim) \
        + multiply(corrupt_left_embedding, corrupt_right_embedding, vector_dim);
        if (cost_tmp > 0) {
			count_train++;
            cost += cost_tmp;
            real left_gradient,corrupt_left_gradient,right_gradient,corrupt_right_gradient;
            for (int j = 0; j < vector_dim; ++j) {
                left_gradient = -right_embedding[j];
                right_gradient = -left_embedding[j];
                corrupt_left_gradient =  corrupt_right_embedding[j];
                corrupt_right_gradient = corrupt_left_embedding[j];
                
                left_embedding[j] -= learn_rate_r * left_gradient;
                right_embedding[j] -= learn_rate_r * right_gradient;
                corrupt_left_embedding[j] -= learn_rate_r * corrupt_left_gradient;
                corrupt_right_embedding[j] -= learn_rate_r * corrupt_right_gradient;
            }   
        }
    }
	std::cout<<count_train<< " pairs been trained.\n";
}

void update_embedding_relation_unstructure_euler(std::vector<Triple> &thread_triplet, real &cost) {
    real *res1 = new real [vector_dim];
    real *res2 = new real [vector_dim];
	real sum1, sum2;
	//srand((int)time(0));
    int count_train=0;
    for (unsigned int i = 0; i < thread_triplet.size(); ++i) {
        int lid = thread_triplet[i].lid;
        int rid = thread_triplet[i].rid;
        int corrupt_lid, corrupt_rid;
        if(rand()%2 == 0) {
            corrupt_lid = rand()%entry_size;
            corrupt_rid = rid;
        } else {
            corrupt_lid = lid;
            corrupt_rid = rand()%entry_size;
        }
		
        real *left_embedding = entry_vec + lid * vector_dim;
        real *right_embedding = entry_vec + rid * vector_dim;
        real *corrupt_left_embedding = entry_vec + corrupt_lid * vector_dim;
        real *corrupt_right_embedding = entry_vec + corrupt_rid * vector_dim;
        sum1 = 0; 
		sum2 = 0;
        for (int j = 0; j < vector_dim; ++j) {
			res1[j] = left_embedding[j] - right_embedding[j];
			sum1 += fabs(res1[j]);
			//std::cout<<left_embedding[j] <<" "<< rel_embedding[j] <<" "<< right_embedding[j] <<" "<<sum1<<"\n";
		}
        for (int j = 0; j < vector_dim; ++j) {
			res2[j] = corrupt_left_embedding[j] - corrupt_right_embedding[j];
			sum2 += fabs(res2[j]);
		}
		
        real cost_tmp = 2 + sum1 - sum2;

        if (cost_tmp > 0) {
			count_train+=1;
            cost += cost_tmp;
            for(int j = 0; j < vector_dim; ++j) {
				real left_grad, right_grad, corrupt_left_grad, corrupt_right_grad;
				if (res1[j] > 0) {
					left_grad = 1;
					right_grad = -1;
				} else if (res1[j] < 0) {
					left_grad = -1;
					right_grad = 1;
				}
				
				if (res2[j] > 0) {
					corrupt_left_grad = -1;
					corrupt_right_grad = 1;
				} else if (res2[j] < 0) {
					corrupt_left_grad = 1;
					corrupt_right_grad = -1;
				}
				//std::cout<<learn_rate_r * left_grad<< " "<< learn_rate_r * corrupt_left_grad<< " "<< learn_rate_r_rel * rel_grad<< "\n";
				left_embedding[j] -= learn_rate_r * left_grad;
				right_embedding[j] -= learn_rate_r * right_grad;
				corrupt_left_embedding[j] -= learn_rate_r * corrupt_left_grad;
				corrupt_right_embedding[j] -= learn_rate_r * corrupt_right_grad;
            }
        }

    }
	std::cout<<count_train<< " pairs been trained.\n";
    delete [] res1;
    delete [] res2;
}

void update_embedding_relation_unstructure_euler_batch(std::vector<Triple> &thread_triplet, real &cost) {
    real *res1 = new real [vector_dim];
    real *res2 = new real [vector_dim];
	real sum1, sum2;
	srand((int)time(0));
	real *gradient = new real [entry_size * vector_dim];
	memset(gradient,0,sizeof(real) * entry_size * vector_dim);
	std::random_shuffle(thread_triplet.begin(),thread_triplet.end());
    for (unsigned int i = 0; i < thread_triplet.size(); ++i) {
        int lid = thread_triplet[i].lid;
        int rid = thread_triplet[i].rid;
        int corrupt_lid, corrupt_rid;
        if(rand()%2 == 0) {
            corrupt_lid = rand()%entry_size;
            corrupt_rid = rid;
        } else {
            corrupt_lid = lid;
            corrupt_rid = rand()%entry_size;
        }
		
        real *left_embedding = entry_vec + lid * vector_dim;
        real *right_embedding = entry_vec + rid * vector_dim;
        real *corrupt_left_embedding = entry_vec + corrupt_lid * vector_dim;
        real *corrupt_right_embedding = entry_vec + corrupt_rid * vector_dim;
        sum1 = 0; 
		sum2 = 0;
        for (int j = 0; j < vector_dim; ++j) {
			res1[j] = left_embedding[j] - right_embedding[j];
			sum1 += fabs(res1[j]);
			//std::cout<<left_embedding[j] <<" "<< rel_embedding[j] <<" "<< right_embedding[j] <<" "<<sum1<<"\n";
		}
        for (int j = 0; j < vector_dim; ++j) {
			res2[j] = corrupt_left_embedding[j] - corrupt_right_embedding[j];
			sum2 += fabs(res2[j]);
		}
		
        real cost_tmp = 2 + sum1 - sum2;

        if (cost_tmp > 0) {
            cost += cost_tmp;
            for(int j = 0; j < vector_dim; ++j) {
				if (res1[j] > 0) {
					gradient[lid * vector_dim + j] += 1;
					gradient[rid * vector_dim + j] += -1;
				} else if (res1[j] < 0) {
					gradient[lid * vector_dim + j] += -1;
					gradient[rid * vector_dim + j] += 1;
				}
				
				if (res2[j] > 0) {
					gradient[corrupt_lid * vector_dim + j] += -1;
					gradient[corrupt_rid * vector_dim + j] += 1;
				} else if (res2[j] < 0) {
					gradient[corrupt_lid * vector_dim + j] += 1;
					gradient[corrupt_rid * vector_dim + j] += -1;
				}
				//std::cout<<learn_rate_r * left_grad<< " "<< learn_rate_r * corrupt_left_grad<< " "<< learn_rate_r_rel * rel_grad<< "\n";

            }
        }
		
		if(i %100 == 99) {
			for(int j = 0; j < entry_size; ++j) {
				for(int k = 0; k < vector_dim; ++k) {
					entry_vec[j * vector_dim + k] -= learn_rate_r * gradient[j * vector_dim + k];
				}
			}
			memset(gradient,0,sizeof(real) * entry_size * vector_dim);
		}

    }
	delete [] gradient;
    delete [] res1;
    delete [] res2;
}

void update_embedding_relation_transE_sphere(std::vector<Triple> &thread_triplet, real &cost) {
    real *addition = new real [vector_dim];
    real *addition2 = new real [vector_dim];
    for (unsigned int i = 0; i < thread_triplet.size(); ++i) {
        int lid = thread_triplet[i].lid;
        int relid = thread_triplet[i].relid;
        int rid = thread_triplet[i].rid;
        int corrupt_lid, corrupt_rid;
        if(rand()%2 == 0) {
            corrupt_lid = rand()%entry_size;
            corrupt_rid = rid;
        } else {
            corrupt_lid = lid;
            corrupt_rid = rand()%entry_size;
        }
        real *left_embedding = entry_vec + lid * vector_dim;
        real *right_embedding = entry_vec + rid * vector_dim;
        real *rel_embedding = relation_vec + relid * vector_dim;
        real *corrupt_left_embedding = entry_vec + corrupt_lid * vector_dim;
        real *corrupt_right_embedding = entry_vec + corrupt_rid * vector_dim;
        
        for (int j = 0; j < vector_dim; ++j) addition[j] = left_embedding[j] + rel_embedding[j];
        for (int j = 0; j < vector_dim; ++j) addition2[j] = corrupt_left_embedding[j] + rel_embedding[j];
		
        real cost_tmp = gama_r - multiply(addition, right_embedding, vector_dim) + multiply(addition2, corrupt_right_embedding, vector_dim);
        real left_grad, right_grad, rel_grad, corrupt_left_grad, corrupt_right_grad;
        if (cost_tmp > 0) {
            cost += cost_tmp;
            for(int j = 0; j < vector_dim; ++j) {
                left_grad = -right_embedding[j];
                right_grad = -(left_embedding[j] + rel_embedding[j]);
                corrupt_left_grad = corrupt_right_embedding[j];
                corrupt_right_grad = corrupt_left_embedding[j] + rel_embedding[j];
                rel_grad = -right_embedding[j] + corrupt_right_embedding[j];
                
                left_embedding[j] -= learn_rate_r * left_grad;
                right_embedding[j] -= learn_rate_r * right_grad;
                corrupt_left_embedding[j] -= learn_rate_r * corrupt_left_grad;
                corrupt_right_embedding[j] -= learn_rate_r * corrupt_right_grad;
                rel_embedding[j] -= learn_rate_r_rel * rel_grad;
            }
            
        }

    }
    delete [] addition;
    delete [] addition2;
}

void update_embedding_relation_transE(std::vector<Triple> &thread_triplet, real &cost) {
    real *res1 = new real [vector_dim];
    real *res2 = new real [vector_dim];
	real sum1, sum2;
	srand((int)time(0));

    for (unsigned int i = 0; i < thread_triplet.size(); ++i) {
        int lid = thread_triplet[i].lid;
        int relid = thread_triplet[i].relid;
        int rid = thread_triplet[i].rid;
        int corrupt_lid, corrupt_rid;
        if(rand()%2 == 0) {
            corrupt_lid = rand()%entry_size;
            corrupt_rid = rid;
        } else {
            corrupt_lid = lid;
            corrupt_rid = rand()%entry_size;
        }
		
        real *left_embedding = entry_vec + lid * vector_dim;
        real *right_embedding = entry_vec + rid * vector_dim;
        real *rel_embedding = relation_vec + relid * vector_dim;
        real *corrupt_left_embedding = entry_vec + corrupt_lid * vector_dim;
        real *corrupt_right_embedding = entry_vec + corrupt_rid * vector_dim;
        sum1 = 0; 
		sum2 = 0;
        for (int j = 0; j < vector_dim; ++j) {
			res1[j] = left_embedding[j] + rel_embedding[j] - right_embedding[j];
			
			sum1 += fabs(res1[j]);
			//std::cout<<left_embedding[j] <<" "<< rel_embedding[j] <<" "<< right_embedding[j] <<" "<<sum1<<"\n";
		}
        for (int j = 0; j < vector_dim; ++j) {
			res2[j] = corrupt_left_embedding[j] + rel_embedding[j] - corrupt_right_embedding[j];
			sum2 += fabs(res2[j]);
		}
		
        real cost_tmp = 2 + sum1 - sum2;

        if (cost_tmp > 0) {
            cost += cost_tmp;
            for(int j = 0; j < vector_dim; ++j) {
				real left_grad, right_grad, corrupt_left_grad, corrupt_right_grad, rel_grad=0;
				if (res1[j] > 0) {
					left_grad = 1;
					rel_grad = 1;
					right_grad = -1;
				} else if (res1[j] < 0) {
					left_grad = -1;
					rel_grad = -1;
					right_grad = 1;
				}
				
				if (res2[j] > 0) {
					corrupt_left_grad = -1;
					rel_grad += -1;
					corrupt_right_grad = 1;
				} else if (res2[j] < 0) {
					corrupt_left_grad = 1;
					rel_grad += 1;
					corrupt_right_grad = -1;
				}
				//std::cout<<learn_rate_r * left_grad<< " "<< learn_rate_r * corrupt_left_grad<< " "<< learn_rate_r_rel * rel_grad<< "\n";
				left_embedding[j] -= learn_rate_r * left_grad;
				right_embedding[j] -= learn_rate_r * right_grad;
				corrupt_left_embedding[j] -= learn_rate_r * corrupt_left_grad;
				corrupt_right_embedding[j] -= learn_rate_r * corrupt_right_grad;
				rel_embedding[j] -= learn_rate_r_rel * rel_grad;
            }
        }

    }
    delete [] res1;
    delete [] res2;
}

void update_embedding_relation_transR(std::vector<Triple> &thread_triplet, real &cost) {
    real *grad_transform = new real [vector_dim * vector_dim];
    real *grad_left = new real [vector_dim];
    real *grad_right = new real [vector_dim];
    real *grad_corrupt_left = new real [vector_dim];
    real *grad_corrupt_right = new real [vector_dim];
    
    real *transform_left = new real [vector_dim];
    real *transform_right = new real [vector_dim];
    real *transform_corrupt_left = new real [vector_dim];
    real *transform_corrupt_right = new real [vector_dim];
    
    for (unsigned int id = 0; id < thread_triplet.size(); ++id) {
        int lid = thread_triplet[id].lid;
        int relid = thread_triplet[id].relid;
        int rid = thread_triplet[id].rid;
        int corrupt_lid, corrupt_rid;
        if(rand()%5 == 0) {//bern
            corrupt_lid = rand()%entry_size;
            corrupt_rid = rid;
        } else {
            corrupt_lid = lid;
            corrupt_rid = rand()%entry_size;
        }
        real *left_embedding = entry_vec + lid * vector_dim;
        real *right_embedding = entry_vec + rid * vector_dim;
        real *rel_embedding = relation_vec + relid * vector_dim;
        real *transform_matrix = transform + relid * vector_dim * vector_dim;
        real *corrupt_left_embedding = entry_vec + corrupt_lid * vector_dim;
        real *corrupt_right_embedding = entry_vec + corrupt_rid * vector_dim;
        
        real sum1 = 0;
        for(int i = 0; i < vector_dim; ++i) {
            real tmp1 = multiply(transform_matrix + i * vector_dim, left_embedding, vector_dim);
            real tmp2 = multiply(transform_matrix + i * vector_dim, right_embedding, vector_dim);
            sum1 += (tmp1 + rel_embedding[i]) * tmp2;
        }
        
        real sum2 = 0;
        for(int i = 0; i < vector_dim; ++i) {
            real tmp1 = multiply(transform_matrix + i * vector_dim, corrupt_left_embedding, vector_dim);
            real tmp2 = multiply(transform_matrix + i * vector_dim, corrupt_right_embedding, vector_dim);
            sum2 += (tmp1 + rel_embedding[i]) * tmp2;
        }
        
        real cost_tmp = gama_r - sum1 + sum2;
        if (cost_tmp > 0) {
            cost +=cost_tmp;
            
            bzero(grad_left, vector_dim * sizeof(real));
            bzero(grad_right, vector_dim * sizeof(real));
            bzero(grad_corrupt_left, vector_dim * sizeof(real));
            bzero(grad_corrupt_right, vector_dim * sizeof(real));
            bzero(grad_transform, vector_dim * vector_dim * sizeof(real));
            
            for(int i = 0; i < vector_dim; ++i) {
                transform_left[i] = multiply(transform_matrix + vector_dim * i, left_embedding, vector_dim);
                transform_right[i] = multiply(transform_matrix + vector_dim * i, right_embedding, vector_dim);
                transform_corrupt_left[i] = multiply(transform_matrix + vector_dim * i, corrupt_left_embedding, vector_dim);
                transform_corrupt_right[i] = multiply(transform_matrix + vector_dim * i, corrupt_right_embedding, vector_dim);
            }
            
            for(int j = 0; j < vector_dim; ++j) {
                for(int i = 0; i < vector_dim; ++i) {
                    grad_left[j] += -transform_right[i] * transform_matrix[vector_dim * i + j];
                    grad_right[j] += - (transform_left[i] + rel_embedding[i]) * transform_matrix[vector_dim * i + j];
                    grad_corrupt_left[j] += transform_corrupt_right[i] * transform_matrix[vector_dim * i + j];
                    grad_corrupt_right[j] += (transform_corrupt_left[i] + rel_embedding[i]) * transform_matrix[vector_dim * i + j];
                    
                    grad_transform[vector_dim * i + j] += - (transform_right[i] * left_embedding[j] + \
                                                             (transform_left[i] + rel_embedding[i]) * right_embedding[j]) \
                                                          + (transform_corrupt_right[i] * corrupt_left_embedding[j] + \
                                                             (transform_corrupt_left[i] + rel_embedding[i]) * corrupt_right_embedding[j]);
                }
            }
            
            for(int i = 0; i < vector_dim; ++i) {
                rel_embedding[i] -= learn_rate_r_rel * (- transform_right[i] + transform_corrupt_right[i]);
                left_embedding[i] -= learn_rate_r * grad_left[i];
                right_embedding[i] -= learn_rate_r * grad_right[i];
                corrupt_left_embedding[i] -= learn_rate_r * grad_corrupt_left[i];
                corrupt_right_embedding[i] -= learn_rate_r * grad_corrupt_right[i];
            }
        }

    }
    delete [] grad_transform;
    delete [] grad_corrupt_left;
    delete [] grad_corrupt_right;
    delete [] grad_left;
    delete [] grad_right;
    delete [] transform_left;
    delete [] transform_right;
    delete [] transform_corrupt_left;
    delete [] transform_corrupt_right;
}

void update_embedding_relation_sphere_transE(std::vector<Triple> &thread_triplet, real &cost) {
    real *grad_transform = new real [vector_dim * vector_dim];
    real *grad_left = new real [vector_dim];
    real *grad_right = new real [vector_dim];
    real *grad_corrupt_left = new real [vector_dim];
    real *grad_corrupt_right = new real [vector_dim];
    
    
    for (unsigned int id = 0; id < thread_triplet.size(); ++id) {
        int lid = thread_triplet[id].lid;
        int relid = thread_triplet[id].relid;
        int rid = thread_triplet[id].rid;
        int corrupt_lid, corrupt_rid;
        if(rand()%2 == 0) {//bern
            corrupt_lid = rand()%entry_size;
            corrupt_rid = rid;
        } else {
            corrupt_lid = lid;
            corrupt_rid = rand()%entry_size;
        }
        real *left_embedding = entry_vec + lid * vector_dim;
        real *right_embedding = entry_vec + rid * vector_dim;
        real *transform_matrix = transform + relid * vector_dim * vector_dim;
        real *corrupt_left_embedding = entry_vec + corrupt_lid * vector_dim;
        real *corrupt_right_embedding = entry_vec + corrupt_rid * vector_dim;
        
        real res1 = 0;
        for(int i = 0; i < vector_dim; ++i) {
            real tmp = multiply(transform_matrix + i * vector_dim, left_embedding, vector_dim);
            res1 += tmp  * right_embedding[i];
        }
        
        real res2 = 0;
        for(int i = 0; i < vector_dim; ++i) {
            real tmp = multiply(transform_matrix + i * vector_dim, corrupt_left_embedding, vector_dim);
            res2 += tmp  * corrupt_right_embedding[i];
        }
        
        real cost_tmp = 1 - res1 + res2;
        if (cost_tmp > 0) {
            cost +=cost_tmp;
            
            bzero(grad_left, vector_dim * sizeof(real));
            bzero(grad_right, vector_dim * sizeof(real));
            bzero(grad_corrupt_left, vector_dim * sizeof(real));
            bzero(grad_corrupt_right, vector_dim * sizeof(real));
            bzero(grad_transform, vector_dim * vector_dim * sizeof(real));
            
			for(int j = 0; j < vector_dim; ++j) {
				for(int i = 0; i < vector_dim; ++i) grad_left[j] += -right_embedding[i] * transform_matrix[vector_dim * i + j];
				for(int i = 0; i < vector_dim; ++i) grad_corrupt_left[j] += corrupt_right_embedding[i] * transform_matrix[vector_dim * i + j];
			}
			
			for(int i = 0; i < vector_dim; ++i) {
				for(int j = 0; j < vector_dim; ++j) grad_right[i] += -left_embedding[j] * transform_matrix[vector_dim * i + j];
				for(int j = 0; j < vector_dim; ++j) grad_corrupt_right[i] += corrupt_left_embedding[j] * transform_matrix[vector_dim * i + j];
			}
			
			for(int i = 0; i < vector_dim; ++i) for(int j = 0; j < vector_dim; ++j) grad_transform[vector_dim * i + j] = - right_embedding[i] * left_embedding[j] \
			                                                                                                             + corrupt_right_embedding[i] * corrupt_left_embedding[j];
            
            
            for(int i = 0; i < vector_dim; ++i) {
                left_embedding[i] -= learn_rate_r * grad_left[i];
                right_embedding[i] -= learn_rate_r * grad_right[i];
                corrupt_left_embedding[i] -= learn_rate_r * grad_corrupt_left[i];
                corrupt_right_embedding[i] -= learn_rate_r * grad_corrupt_right[i];
				for(int j = 0; j < vector_dim; ++j) transform_matrix[vector_dim * i + j] -= learn_rate_r_rel * grad_transform[vector_dim * i + j];
            }
        }

    }
    delete [] grad_transform;
    delete [] grad_corrupt_left;
    delete [] grad_corrupt_right;
    delete [] grad_left;
    delete [] grad_right;

}




void output_embedding(const char *filename, const char *run_type) {
    std::fstream fout(filename, std::ios::out);
    fout<<run_type<<" "<<entry_size<<" "<<vector_dim;
    if(rel_size > 0) fout<<" "<<rel_size;
    fout<<std::endl;
    for (int i = 0; i < entry_size; ++i) {
        //std::string name;
        //for (unsigned int j = 0; j < strlen(entry_array[i].entry_name); ++j)
        //    if (entry_array[i].entry_name[j] != ' ')
        //        name += entry_array[i].entry_name[j];/**/

        fout<<entry_array[i].entry_name;
        for(int j = 0; j < vector_dim; ++j) fout<<" "<<entry_vec[i * vector_dim + j];
        fout<<std::endl;
    }
    for (int i = 0; i < rel_size; ++i) {
        std::string name = id2rel[i];
        fout<<name;
        for(int j = 0; j < vector_dim; ++j) fout<<" "<<relation_vec[i * vector_dim + j];
        fout<<std::endl;
    }
    if(!strcmp(run_type,"transr")) {
        for (int i = 0; i < rel_size; ++i) {
            std::string name = id2rel[i];
            fout<<name<<"_transform";
            for(int j = 0; j < vector_dim; ++j) for(int k = 0; k < vector_dim; ++k) fout<<" "<<transform[i * vector_dim * vector_dim + j * vector_dim + k];
            fout<<std::endl;
        }
    }
    fout.close();
	
	std::fstream fout2(wordvec_output_file, std::ios::out);
    fout2<<run_type<<" "<<word_size<<" "<<vector_dim;
    if(rel_size > 0) fout<<" "<<rel_size;
    fout<<std::endl;
    for (int i = 0; i < word_size; ++i) {
        fout<<word_array[i].word;
        for(int j = 0; j < vector_dim; ++j) fout<<" "<<word_vec[i * vector_dim + j];
        fout<<std::endl;
    }
	fout2.close();
}

void average_word2vec_and_output(){
	std::fstream fout("vector", std::ios::out);
    fout<<"fast_tune"<<" "<<entry_size<<" "<<vector_dim;
    fout<<std::endl;
	bzero(entry_vec, entry_size * vector_dim * sizeof(real));
    for (int i = 0; i < entry_size; ++i) {
        //average
        int countword=0;
		//std::cout<<entry_array[i].entry_name<<" "<<entry_array[i].word_num<<std::endl;
		for(int j = 0; j < entry_array[i].word_num; ++j) {
			
			int wid = entry_array[i].word_list[j];
			countword+=1;
			for(int k = 0; k < vector_dim; ++k) {
				entry_vec[i * vector_dim + k] += word_vec[wid * vector_dim + k];
			}
		}
		if(countword != 0) {
			for(int k = 0; k < vector_dim; ++k) {
				entry_vec[i * vector_dim + k] /= (real)countword;
			}
		}
		
		fout<<entry_array[i].entry_name;
        for(int j = 0; j < vector_dim; ++j) fout<<" "<<entry_vec[i * vector_dim + j];
        fout<<std::endl;
    }
    fout.close();
}

/*for topN prediction*/
struct heap_node {
    int index;
    real distance;
};

void adjust_heap(heap_node *max_heap, int k, int index) {
    int j = index;
    while (2 * j + 1 < k) {
        int left = 2 * j + 1;
        int right = 2 * j + 2;
        int max_child = -1;
        if (right >= k) {
            max_child = left;
        } else {
            max_child = (max_heap[left].distance > \
                    max_heap[right].distance ? left : right);
        }
        if (max_heap[max_child].distance > max_heap[j].distance) {
            int tmp_index = max_heap[j].index;
            real tmp_distance = max_heap[j].distance;
            max_heap[j].index = max_heap[max_child].index;
            max_heap[j].distance = max_heap[max_child].distance;
            max_heap[max_child].index = tmp_index;
            max_heap[max_child].distance = tmp_distance;
        } else {
            break;
        }
        j = max_child;
    }
}

void build_heap(heap_node *max_heap, real *dis, int k) {
    // initialize the heap
    for (int i = 0; i < k; i++) {
        max_heap[i].index = i;
        max_heap[i].distance = dis[i];
    }

    for (int i = (k - 1) / 2; i >= 0; i--) {
        int left = 2 * i + 1;
        int right = 2 * i + 2;
        int max_child = -1;
        if (right >= k) {
            max_child = left;
        } else {
            max_child = (max_heap[left].distance > \
                    max_heap[right].distance ? left : right);
        }
        if (max_heap[max_child].distance > max_heap[i].distance) {
            int tmp_index = max_heap[i].index;
            real tmp_distance = max_heap[i].distance;
            max_heap[i].index = max_heap[max_child].index;
            max_heap[i].distance = max_heap[max_child].distance;
            max_heap[max_child].index = tmp_index;
            max_heap[max_child].distance = tmp_distance;
            adjust_heap(max_heap, k, max_child);
        }
    }
} 

// return the top k similar entry
// dis: the distance array of the target entry with other entris
// k: top num
std::vector<int> get_similar_entry(real *dis, int n, int k) {
    heap_node *max_heap = (heap_node *)malloc(sizeof(heap_node) * k);
    
    build_heap(max_heap, dis, k);

    // select top k
    for (int i = k; i < n; i++) {
        if (dis[i] >= max_heap[0].distance) continue;
        max_heap[0].index = i;
        max_heap[0].distance = dis[i];
        adjust_heap(max_heap, k, 0);
    }

    std::vector<int> res;
    for (int i = 0; i < k; i++) {
        res.push_back(max_heap[0].index);
        max_heap[0].index = max_heap[k - 1 - i].index;
        max_heap[0].distance = max_heap[k - 1 - i].distance;
        adjust_heap(max_heap, k - 1 - i, 0);
    }
    std::reverse(res.begin(), res.end());
    free(max_heap);
    return res;
}

void topN(int N){
    real *dis_ent=new real [entry_size];
    real *dis_word=new real [word_size];
    std::ofstream fout(topn_output);
    for (int i = 0; i < entry_size; ++i) {
        real *ent_embedding = &entry_vec[i * vector_dim];
        
        for (int j = 0; j < entry_size; ++j)
            dis_ent[j] = -multiply(ent_embedding, &entry_vec[j * vector_dim], vector_dim);
        
        for (int j = 0; j < word_size; ++j)
            dis_word[j] = -multiply(ent_embedding, &word_vec[j * vector_dim], vector_dim);
        
        std::vector<int> res_ent = get_similar_entry(dis_ent, entry_size, N);   
        std::vector<int> res_word = get_similar_entry(dis_word, word_size, N);
        
        fout<<entry_array[i].entry_name<<":"<<std::endl<<"entry_rank:";
        for (int j = 0; j < N; ++j) fout<<" "<<entry_array[res_ent[j]].entry_name<<",";
        fout<<std::endl<<"word_rank:";
        for (int j = 0; j < N; ++j) fout<<" "<<word_array[res_word[j]].word<<",";
        fout<<std::endl;
    }

    for (int i = 0; i < word_size; ++i) {
        real *word_embedding = &word_vec[i * vector_dim];
        
        for (int j = 0; j < entry_size; ++j)
            dis_ent[j] = -multiply(word_embedding, &entry_vec[j * vector_dim], vector_dim);
        for (int j = 0; j < word_size; ++j)
            dis_word[j] = -multiply(word_embedding, &word_vec[j * vector_dim], vector_dim);
        std::vector<int> res_ent = get_similar_entry(dis_ent, entry_size, N);   
        std::vector<int> res_word = get_similar_entry(dis_word, word_size, N);
        fout<<word_array[i].word<<":"<<std::endl<<"entry_rank:";;
        for (int j = 0; j < N; ++j) fout<<" "<<entry_array[res_ent[j]].entry_name<<",";
        fout<<std::endl<<"word_rank:";
        for (int j = 0; j < N; ++j) fout<<" "<<word_array[res_word[j]].word<<",";
        fout<<std::endl;
    }
    
    delete [] dis_ent;
    delete [] dis_word;
    fout.close();
}



struct thread_args_t {
    int entry_num;
    int *entry_p;
    int triplet_num;
    std::vector<Triple> thread_triplet;
    
    real cost_w;
    real cost_r;
    real cost_num_w;
};

// thread_args a ptr pointing to struct thread_args_t
void *train_model_thread(void *thread_args) {
    struct thread_args_t *m_thread_args = (struct thread_args_t *)thread_args;
    int entry_num = m_thread_args->entry_num;
    int *entry_p = m_thread_args->entry_p;
    //int triplet_num = m_thread_args->triplet_num;
    std::vector<Triple> &thread_triplet = m_thread_args->thread_triplet;
    
    if(learn_pv == true) {
        for (int i = 0; i < entry_num; i++) {
			//if(entry_array[entry_p[i]].word_num<100) continue; 
            if (!strcmp(run_type,"pv") || !strcmp(run_type,"se-pv") || !strcmp(run_type,"transe-pv")||!strcmp(run_type,"pv_word2vec_init")||!strcmp(run_type,"kv_word2vec_init")||!strcmp(run_type,"pv_word2vec_init")||!strcmp(run_type,"pv_word2vec_init_both_pv_and_word2vec"))
				update_embedding_paragraph(entry_p[i], m_thread_args->cost_w, m_thread_args->cost_num_w);
			else if (!strcmp(run_type,"pv_word2vec_fixed") || !strcmp(run_type,"kv_word2vec_fixed") )
				update_embedding_paragraph_withwordfix(entry_p[i], m_thread_args->cost_w, m_thread_args->cost_num_w);
        } 
    }
    if(learn_relation == true) {
        if(!strcmp(run_type,"se") ||!strcmp(run_type,"se_word2vec_init") || !strcmp(run_type,"se-pv") || !strcmp(run_type,"kv_word2vec_init")||!strcmp(run_type,"kv_word2vec_fixed") )
            update_embedding_relation_unstructure(thread_triplet, m_thread_args->cost_r);
		else if(!strcmp(run_type,"se_euler_word2vec_init") || !strcmp(run_type,"se_euler"))
			update_embedding_relation_unstructure_euler(thread_triplet, m_thread_args->cost_r);
        else if (!strcmp(run_type,"transe_word2vec_init") || !strcmp(run_type,"transe-pv"))
            update_embedding_relation_transE(thread_triplet, m_thread_args->cost_r);
        else if (!strcmp(run_type,"transr") || !strcmp(run_type,"transr-pv"))
            update_embedding_relation_transR(thread_triplet, m_thread_args->cost_r);
		else if (!strcmp(run_type,"sphere_transe") || !strcmp(run_type,"sphere_transe-pv"))
			update_embedding_relation_sphere_transE(thread_triplet, m_thread_args->cost_r);
		else if (!strcmp(run_type,"fast_tune"))
			update_embedding_relation_unstructure(thread_triplet, m_thread_args->cost_r);
		
		
    }
    pthread_exit(NULL);
}

void load_similarity_test_file(const char *test_file) {
    std::ifstream in_stm(test_file);
    std::string line;
    while (getline(in_stm, line)) {
        std::vector<std::string> l;
        split(line, "\t", l);
        std::vector<std::string> left_l;
        split(l[0]," ",left_l);
        std::vector<std::string> right_l;
        split(l[1]," ",right_l);
        std::vector<int> leftid;
        for (unsigned int i = 0; i < left_l.size(); ++i) {
            int hash = search_entry(left_l[i].c_str());
            leftid.push_back(entry_hash[hash]);
            if (hash == -1) {
                std::cout << left_l[i] <<" in the similarity test file does not exist in the model file!" << std::endl;
                exit(1);
            }
        }
        std::vector<int> rightid;
        for (unsigned int i = 0; i < right_l.size(); ++i) {
            int hash = search_entry(right_l[i].c_str());
            rightid.push_back(entry_hash[hash]);
            if (hash == -1) {
                std::cout << right_l[i] <<" in the similarity test file does not exist in the model file!" << std::endl;
                exit(1);
            }
        }
        real score = atof(l[2].c_str());

        TestData_Sim td = {leftid, rightid, score};
        test_array_sim.push_back(td);
    }
    in_stm.close();
}

void load_similarity_test_file_combine(const char *test_file) {
    std::ifstream in_stm(test_file);
    std::string line;
    while (getline(in_stm, line)) {
        std::vector<std::string> l;
        split(line, "\t", l);
		std::vector<std::string> left_l;
		split(l[0]," ",left_l);
		std::vector<std::string> right_l;
        split(l[1]," ",right_l);
        std::vector<int> leftid;
		for (unsigned int i = 0; i < left_l.size(); ++i) {
            int hash = search_word(left_l[i].c_str());
            leftid.push_back(word_hash[hash]);
            if (hash == -1) {
                std::cout << left_l[i] <<" in the similarity test file does not exist in the model file!" << std::endl;
                exit(1);
            }
        }
        std::vector<int> rightid;
        for (unsigned int i = 0; i < right_l.size(); ++i) {
            int hash = search_word(right_l[i].c_str());
            rightid.push_back(word_hash[hash]);
            if (hash == -1) {
                std::cout << right_l[i] <<" in the similarity test file does not exist in the model file!" << std::endl;
                exit(1);
            }
        }
        real score = atof(l[2].c_str());

        TestData_Sim td = {leftid, rightid, score};
        test_array_sim.push_back(td);
		
    }
    in_stm.close();
}

void load_similarity_test_file_word() {
    std::ifstream in_stm("testset4word2vec");
    std::string line;
    while (getline(in_stm, line)) {
        std::vector<std::string> l;
        split(line, "\t", l);
        int hash = search_word(l[0].c_str());
        int leftid = word_hash[hash];
        if (hash == -1) {
            std::cout << l[0] <<" in the similarity test file does not exist in the model file!" << std::endl;
            //exit(1);
			continue;	
        }
        
        hash = search_word(l[1].c_str());
        int rightid = word_hash[hash];
            if (hash == -1) {
                std::cout << l[1] <<" in the similarity test file does not exist in the model file!" << std::endl;
                //exit(1);
			    continue;
            }
        
        real score = atof(l[2].c_str());

        TestData_WordSim td = {leftid, rightid, score};
        test_array_wordsim.push_back(td);
    }
    in_stm.close();
}



void load_relation_test_file(const char *test_file) {
    std::ifstream in_stm(test_file);
    std::string line;
    while (getline(in_stm, line)) {
        std::vector<std::string> l;
        split(line, "\t", l);
        std::string left=l[0];
        std::string right=l[2];
        std::string rel=l[1];

        int hash = search_entry(left.c_str());
        int leftid = entry_hash[hash];
        if (hash == -1) {
            std::cout << left <<" in the relation test file does not exist in the model file!" << std::endl;
            exit(1);
        }
        
        hash = search_entry(right.c_str());
        int rightid = entry_hash[hash];
        if (hash == -1) {
            std::cout << right <<" in the relation test file does not exist in the model file!" << std::endl;
            exit(1);
        }
        
        int relid;
        if(rel2id.find(rel)==rel2id.end())
        {
            std::cout << rel <<" in the relation test file does not exist in the model file!" << std::endl;
            exit(1);
        }
        else
            relid=rel2id[rel];
            
        Triple trip = {leftid, relid, rightid};
        testtriple.push_back(trip);
    }
    in_stm.close();
}
void test_relation_per_iter(int iter) {
    std::cout << "=================iter: " << iter << " relation test begin.==================" << std::endl;
    real top10hit_left = 0;
    real top10hit_right = 0;
    real *midres = new real [vector_dim];
    real *cosine = (real*)calloc(entry_size,sizeof(real));
    std::vector<int> res_ent;
    for(unsigned int i = 0;i < testtriple.size(); ++i)
    {
        int left_id = testtriple[i].lid;
        int right_id = testtriple[i].rid;
        int rel_id = testtriple[i].relid;
        int score =100;
        memset(cosine,0,sizeof(real) * entry_size);
        ////////////////////////////predict tail
        if(!strcmp(run_type,"se") || !strcmp(run_type,"se-pv") ||!strcmp(run_type,"kv_init_word2vec")) {
            for(int j = 0; j < entry_size; ++j)
            {
                cosine[j] = -multiply(entry_vec + left_id * vector_dim, entry_vec + j * vector_dim, vector_dim);
            }
        } else if(!strcmp(run_type,"unstructure_euler") || !strcmp(run_type,"unstructure_euler-pv")) {
            for(int j = 0;j < entry_size; ++j)
            {
                //cosine[j] = -multiply(midres,entry_vec + j * vector_dim, vector_dim);
				for(int k = 0; k < vector_dim; ++k) {
					cosine[j] += fabs(entry_vec[left_id * vector_dim + k] - entry_vec[j * vector_dim + k]);
				}
            }
        } else if (!strcmp(run_type,"transe") || !strcmp(run_type,"transe-pv")) {
            for(int j = 0; j < vector_dim; ++j) midres[j] = entry_vec[left_id * vector_dim + j] + relation_vec[rel_id * vector_dim + j];
            for(int j = 0;j < entry_size; ++j)
            {
                //cosine[j] = -multiply(midres,entry_vec + j * vector_dim, vector_dim);
				for(int k = 0; k < vector_dim; ++k) {
					cosine[j] += fabs(midres[k] - entry_vec[j * vector_dim + k]);
				}
				
            }
        } else if (!strcmp(run_type,"sphere_transe") || !strcmp(run_type,"sphere_transe-pv")) {
            for(int j = 0; j < vector_dim; ++j) midres[j] = multiply(entry_vec + vector_dim * left_id, transform + rel_id * vector_dim * vector_dim + j * vector_dim, vector_dim);
            for(int j = 0;j < entry_size; ++j)
            {
                cosine[j] = -multiply(midres,entry_vec + j * vector_dim, vector_dim);
            }
        } else if (!strcmp(run_type,"transr") || !strcmp(run_type,"transr-pv")) {
            for(int j = 0; j < vector_dim; ++j)
                midres[j] = multiply(transform + rel_id * vector_dim * vector_dim + vector_dim * j, entry_vec + left_id * vector_dim, vector_dim)\
                +  relation_vec[rel_id * vector_dim + j];
            for(int j = 0; j < entry_size; ++j) {
                real mid = multiply(transform + rel_id * vector_dim * vector_dim + vector_dim * j, entry_vec + j * vector_dim, vector_dim);
                for(int k = 0; k < vector_dim; ++k)
                    cosine[j] += midres[k] * mid;
                cosine[j] = -cosine[j];
            }
            
        }
        
        res_ent = get_similar_entry(cosine, entry_size, 10); 
        for(int j=0;j<10;++j)
        {
            if(res_ent[j]==right_id)
            {
                    score=j+1;
                    break;
            }
        }
        
        if(score<=10)top10hit_right+=1;
        
        res_ent.clear();
        std::cout<<score<<" ";
        //////////////////////////predict head
        score=100;
        memset(cosine,0,sizeof(real) * entry_size);
        if(!strcmp(run_type,"se") || !strcmp(run_type,"se-pv")||!strcmp(run_type,"kv_init_word2vec")) {
            for(int j = 0; j < entry_size; ++j)
            {
                cosine[j] = -multiply(entry_vec + right_id * vector_dim, entry_vec + j * vector_dim, vector_dim);
            }
        } else if(!strcmp(run_type,"unstructure_euler") || !strcmp(run_type,"unstructure_euler-pv")) {
            for(int j = 0;j < entry_size; ++j)
            {
                //cosine[j] = -multiply(midres,entry_vec + j * vector_dim, vector_dim);
				for(int k = 0; k < vector_dim; ++k) {
					cosine[j] += fabs(entry_vec[j * vector_dim + k] - entry_vec[right_id * vector_dim + k]);
				}
            }
        } else if (!strcmp(run_type,"transe") || !strcmp(run_type,"transe-pv")) {
            for (int k = 0; k < vector_dim; ++k) midres[k] = relation_vec[rel_id * vector_dim + k] - entry_vec[right_id * vector_dim + k];
            for(int j = 0; j < entry_size; ++j)
            {
				for(int k = 0; k < vector_dim; ++k)
					cosine[j] += fabs(entry_vec[j * vector_dim + k] + midres[k]);
            }
        } else if (!strcmp(run_type,"sphere_transe") || !strcmp(run_type,"sphere_transe-pv")) {
            for(int j = 0;j < entry_size; ++j)
            {
				for(int k = 0; k < vector_dim; ++k) midres[k] = multiply(entry_vec + vector_dim * j, transform + rel_id * vector_dim * vector_dim + k * vector_dim, vector_dim);
                cosine[j] = -multiply(midres,entry_vec + right_id * vector_dim, vector_dim);
            }
        } else if (!strcmp(run_type,"transr") || !strcmp(run_type,"transr-pv")) {
            for(int j = 0; j < vector_dim; ++j)
                midres[j] = multiply(transform + rel_id * vector_dim * vector_dim + vector_dim * j, entry_vec + right_id * vector_dim, vector_dim)\
                -  relation_vec[rel_id * vector_dim + j];
            for(int j = 0; j < entry_size; ++j) {
                real mid = multiply(transform + rel_id * vector_dim * vector_dim + vector_dim * j, entry_vec + j * vector_dim, vector_dim);
                for(int k = 0; k < vector_dim; ++k)
                    cosine[j] += midres[k] * mid;
                cosine[j] = -cosine[j];
            }
        }
        res_ent = get_similar_entry(cosine, entry_size, 10);
        
        for(int j=0;j<10;++j)
        {
            if(res_ent[j]==left_id)
            {
                    score=j+1;
                    break;
            }
        }

        if(score<=10)top10hit_left+=1;
        res_ent.clear();
        std::cout<<score<<std::endl;
        
    }
    delete [] midres;
    delete [] cosine;
    top10hit_left/=testtriple.size();
    top10hit_right/=testtriple.size();
    std::cout<<"validation set: top10hit_right rate:"<<top10hit_right<<std::endl;
    std::cout<<"validation set: top10hit_left rate:"<<top10hit_left<<std::endl;
    std::cout<<"validation set: top10hit_average rate:"<<(top10hit_left+top10hit_right)/2<<std::endl;
    std::cout << "=================iter: " << iter << " relation end.==================" << std::endl;
}

void test_similarity_euler_per_iter(int iter) {
    std::cout << "=================iter: " << iter << " similarity test begin.==================" << std::endl;

    // Spearman rank-order correlation coefficient
    std::vector<Id_Score_Rank> score_rank;
    std::vector<Id_Score_Rank> score_rank_answer;
    for (unsigned int i = 0; i < test_array_sim.size(); ++i) {
        real maxcosine=-10000;
        for (unsigned int lefti = 0; lefti < test_array_sim[i].leftindex.size(); ++lefti) {
            for (unsigned int righti = 0; righti < test_array_sim[i].rightindex.size(); ++righti) {
				real score=0;
				for (int j = 0; j < vector_dim; ++j) {
					score -= fabs(entry_vec[test_array_sim[i].leftindex[lefti] * vector_dim + j] \
         					- entry_vec[test_array_sim[i].rightindex[righti] * vector_dim + j]);
				}
			
                if (score > maxcosine) {
                    maxcosine = score;
                }
            }
        }

        Id_Score_Rank isr = {i, maxcosine, 0};
        Id_Score_Rank isr_answer = {i, test_array_sim[i].score, 0};
        score_rank.push_back(isr);
        score_rank_answer.push_back(isr_answer);
    }
    sort(score_rank.begin(), score_rank.end(), compareScore);
    sort(score_rank_answer.begin(), score_rank_answer.end(), compareScore);

    for (unsigned int i = 0; i < score_rank.size(); ++i) {
        score_rank[i].rank = i;
        score_rank_answer[i].rank = i;
    }

    sort(score_rank.begin(),score_rank.end(),compareId);
    sort(score_rank_answer.begin(),score_rank_answer.end(),compareId);

    
    real sum_delta=0;
    for (unsigned int i = 0; i < test_array_sim.size(); ++i) {
        std::cout << entry_array[test_array_sim[i].leftindex[0]].entry_name << '\t' \
            << entry_array[test_array_sim[i].rightindex[0]].entry_name << '\t' \
            << score_rank[i].rank << '\t' << score_rank_answer[i].rank << '\t' \
            << test_array_sim[i].score << std::endl;
        sum_delta += pow(score_rank[i].rank - score_rank_answer[i].rank, 2);
    }

    real coefficient = 1.0 - 6.0 * sum_delta / (real)test_array_sim.size() / (real)(pow(test_array_sim.size(),2) - 1);
    std::cout << "Spearman rank-order correlation coefficient: " << coefficient << std::endl;


    // Pearson correlation coefficient
    real innerproduct_sum=0;
    real predict_sum=0;
    real answer_sum=0;
    real predict_pow_sum=0;
    real answer_pow_sum=0;
    for (unsigned int i=0;i<score_rank.size();++i) {
        predict_sum+=score_rank[i].score;
        predict_pow_sum+=pow(score_rank[i].score, 2);
        answer_sum+=score_rank_answer[i].score;
        answer_pow_sum+=pow(score_rank_answer[i].score, 2);
        innerproduct_sum+=score_rank[i].score * score_rank_answer[i].score;
    }
    coefficient = (score_rank.size() * innerproduct_sum - predict_sum * answer_sum) / \
        sqrt(score_rank.size() * predict_pow_sum - pow(predict_sum, 2)) / \
        sqrt(score_rank.size() * answer_pow_sum - pow(answer_sum, 2));
    std::cout << "Pearson correlation coefficient: " << coefficient << std::endl;

    std::cout << "=================iter: " << iter << " similarity end.==================" << std::endl << std::endl;
}

void test_similarity_per_iter(int iter) {
    std::cout << "=================iter: " << iter << " similarity test begin.==================" << std::endl;

    // Spearman rank-order correlation coefficient
    std::vector<Id_Score_Rank> score_rank;
    std::vector<Id_Score_Rank> score_rank_answer;
    for (unsigned int i = 0; i < test_array_sim.size(); ++i) {
        real maxcosine=-10000;
        for (unsigned int lefti = 0; lefti < test_array_sim[i].leftindex.size(); ++lefti) {
            for (unsigned int righti = 0; righti < test_array_sim[i].rightindex.size(); ++righti) {
                real score = multiply(&entry_vec[test_array_sim[i].leftindex[lefti] * vector_dim], \
                            &entry_vec[test_array_sim[i].rightindex[righti] * vector_dim], vector_dim);
                if (score > maxcosine) {
                    maxcosine = score;
                }
            }
        }

        Id_Score_Rank isr = {i, maxcosine, 0};
        Id_Score_Rank isr_answer = {i, test_array_sim[i].score, 0};
        score_rank.push_back(isr);
        score_rank_answer.push_back(isr_answer);
    }
    sort(score_rank.begin(), score_rank.end(), compareScore);
    sort(score_rank_answer.begin(), score_rank_answer.end(), compareScore);

    for (unsigned int i = 0; i < score_rank.size(); ++i) {
        score_rank[i].rank = i;
        score_rank_answer[i].rank = i;
    }

    sort(score_rank.begin(),score_rank.end(),compareId);
    sort(score_rank_answer.begin(),score_rank_answer.end(),compareId);

    
    real sum_delta=0;
    for (unsigned int i = 0; i < test_array_sim.size(); ++i) {
        std::cout << entry_array[test_array_sim[i].leftindex[0]].entry_name << '\t' \
            << entry_array[test_array_sim[i].rightindex[0]].entry_name << '\t' \
            << score_rank[i].rank << '\t' << score_rank_answer[i].rank << '\t' \
            << test_array_sim[i].score << std::endl;
        sum_delta += pow(score_rank[i].rank - score_rank_answer[i].rank, 2);
    }

    real coefficient = 1.0 - 6.0 * sum_delta / (real)test_array_sim.size() / (real)(pow(test_array_sim.size(),2) - 1);
    std::cout << "Spearman rank-order correlation coefficient: " << coefficient << std::endl;


    // Pearson correlation coefficient
    real innerproduct_sum=0;
    real predict_sum=0;
    real answer_sum=0;
    real predict_pow_sum=0;
    real answer_pow_sum=0;
    for (unsigned int i=0;i<score_rank.size();++i) {
        predict_sum+=score_rank[i].score;
        predict_pow_sum+=pow(score_rank[i].score, 2);
        answer_sum+=score_rank_answer[i].score;
        answer_pow_sum+=pow(score_rank_answer[i].score, 2);
        innerproduct_sum+=score_rank[i].score * score_rank_answer[i].score;
    }
    coefficient = (score_rank.size() * innerproduct_sum - predict_sum * answer_sum) / \
        sqrt(score_rank.size() * predict_pow_sum - pow(predict_sum, 2)) / \
        sqrt(score_rank.size() * answer_pow_sum - pow(answer_sum, 2));
    std::cout << "Pearson correlation coefficient: " << coefficient << std::endl;

    std::cout << "=================iter: " << iter << " similarity end.==================" << std::endl << std::endl;
}

void test_wordsimilarity_per_iter(int iter) {
    std::cout << "=================iter: " << iter << " similarity test begin.==================" << std::endl;

    // Spearman rank-order correlation coefficient
    std::vector<Id_Score_Rank> score_rank;
    std::vector<Id_Score_Rank> score_rank_answer;
    for (unsigned int i = 0; i < test_array_wordsim.size(); ++i) {
		int leftid=test_array_wordsim[i].leftindex;
		int rightid=test_array_wordsim[i].rightindex;

        real score = multiply(&word_vec[leftid * vector_dim], \
                            &word_vec[rightid * vector_dim], vector_dim);

        

        Id_Score_Rank isr = {i, score, 0};
        Id_Score_Rank isr_answer = {i, test_array_wordsim[i].score, 0};
        score_rank.push_back(isr);
        score_rank_answer.push_back(isr_answer);
    }
    sort(score_rank.begin(), score_rank.end(), compareScore);
    sort(score_rank_answer.begin(), score_rank_answer.end(), compareScore);

    for (unsigned int i = 0; i < score_rank.size(); ++i) {
        score_rank[i].rank = i;
        score_rank_answer[i].rank = i;
    }

    sort(score_rank.begin(),score_rank.end(),compareId);
    sort(score_rank_answer.begin(),score_rank_answer.end(),compareId);

    
    real sum_delta=0;
    for (unsigned int i = 0; i < test_array_wordsim.size(); ++i) {
        std::cout << entry_array[test_array_wordsim[i].leftindex].entry_name << '\t' \
            << entry_array[test_array_wordsim[i].rightindex].entry_name << '\t' \
            << score_rank[i].rank << '\t' << score_rank_answer[i].rank << '\t' \
            << test_array_wordsim[i].score << std::endl;
        sum_delta += pow(score_rank[i].rank - score_rank_answer[i].rank, 2);
    }

    real coefficient = 1.0 - 6.0 * sum_delta / (real)test_array_wordsim.size() / (real)(pow(test_array_wordsim.size(),2) - 1);
    std::cout << "Spearman rank-order correlation coefficient: " << coefficient << std::endl;


    // Pearson correlation coefficient
    real innerproduct_sum=0;
    real predict_sum=0;
    real answer_sum=0;
    real predict_pow_sum=0;
    real answer_pow_sum=0;
    for (unsigned int i=0;i<score_rank.size();++i) {
        predict_sum+=score_rank[i].score;
        predict_pow_sum+=pow(score_rank[i].score, 2);
        answer_sum+=score_rank_answer[i].score;
        answer_pow_sum+=pow(score_rank_answer[i].score, 2);
        innerproduct_sum+=score_rank[i].score * score_rank_answer[i].score;
    }
    coefficient = (score_rank.size() * innerproduct_sum - predict_sum * answer_sum) / \
        sqrt(score_rank.size() * predict_pow_sum - pow(predict_sum, 2)) / \
        sqrt(score_rank.size() * answer_pow_sum - pow(answer_sum, 2));
    std::cout << "Pearson correlation coefficient: " << coefficient << std::endl;

    std::cout << "=================iter: " << iter << " similarity end.==================" << std::endl << std::endl;
}




void load_word2vec_and_init(const char *filename) { 
	std::ifstream inStm(filename);
    std::string line; 
	getline(inStm, line);
    while (getline(inStm, line)) {
        std::vector<std::string> l;
		split(line, " ", l);
		std::string word = l[0];
		int hash = search_word(word.c_str());
		int wordhash;
		if (-1 == hash) {
            wordhash = get_insert_word_hash(word.c_str());
            // save entity name to entry array
            word_array[word_size].word = (char *)calloc(word.length() + 1, sizeof(char));
            strcpy(word_array[word_size].word, word.c_str());
            word_array[word_size].word[word.size()] = '\0';
            word_hash[wordhash] = word_size;
            word_size++;
            if (word_size % 1000 == 0) std::cout << "word size: " << word_size << std::endl;
        }
		
	}
	inStm.close();
	inStm.clear();
	
	init_vector();
	
	inStm.open(filename);
    int num = 0;
	getline(inStm, line);
    while (getline(inStm, line)) {
        std::vector<std::string> l;
		split(line, " ", l);
		std::string word = l[0];
		int hash = search_word(word.c_str());
	
            // save entity name to entry array
		num++;
        int wid = word_hash[hash];
		
		//std::cout<<word_array[wid].word<<std::endl;
		real *word_embedding = word_vec + wid * vector_dim;
		for(int i = 0; i < vector_dim; ++i) {
			word_embedding[i] = atof(l[i+1].c_str());
		}
		//std::cout<<word_vec[word_hash[search_word(word.c_str())] * vector_dim]<<std::endl;
    }
	std::cout<<num<<" words founded in word2vec\n";
	
	inStm.close();

}

void load_word2vec_and_init_pv(const char *filename) { 
	std::ifstream inStm(filename);
    std::string line; 
    int num = 0;
	getline(inStm, line);
    while (getline(inStm, line)) {
	//std::cout<<line<<std::endl;
        std::vector<std::string> l;
		split(line, " ", l);
		std::string ent = l[0];
		int hash = search_entry(ent.c_str());
		//std::cout<<ent<< " "<<hash<<std::endl;
            // save entity name to entry array
		num++;
        int eid = entry_hash[hash];
		real *ent_embedding = entry_vec + eid * vector_dim;
		for(int i = 0; i < vector_dim; ++i) {
			ent_embedding[i] = atof(l[i+1].c_str());
		}
    }
	std::cout<<num<<" entrys founded in word2vec\n";
	
	inStm.close();

}


void train_model_multithread() {
	
    srand((int)time(0));
    // init shuffle vector
    for (int i = 0; i < entry_size; i++) {
            shuffle_vec.push_back(i);
    }
    std::vector<int> local_shuffle_vec(shuffle_vec);
    std::random_shuffle(local_shuffle_vec.begin(), local_shuffle_vec.end());
    
    load_similarity_test_file(similarity_test_file);
	//load_similarity_test_file_word();
    load_relation_test_file(relation_test_file);
    /*init multi-thread args.*/
    pthread_t *pt = (pthread_t *)malloc(thread_num * sizeof(pthread_t));
    struct thread_args_t *threads_args = (struct thread_args_t *)calloc(thread_num, sizeof(thread_args_t));
    int entry_num_per_thread = local_shuffle_vec.size() / thread_num;
    for (int i = 0; i < thread_num - 1; i++) {
        threads_args[i].entry_num = entry_num_per_thread;
        threads_args[i].entry_p = (int *)malloc(entry_num_per_thread * sizeof(int));
    }
    int offset = entry_num_per_thread * (thread_num - 1);
    int last_entry_num = local_shuffle_vec.size() - offset;
    threads_args[thread_num - 1].entry_num = last_entry_num;
    threads_args[thread_num - 1].entry_p = (int *)malloc(last_entry_num * sizeof(int));

    for (int i = 0; i < thread_num - 1; i++) {
        for (int j = 0; j < entry_num_per_thread; j++) {
            threads_args[i].entry_p[j] = local_shuffle_vec[i * entry_num_per_thread + j];
        }
    }
    for (int i = 0; i < last_entry_num; i++) {
        threads_args[thread_num - 1].entry_p[i] = local_shuffle_vec[i + offset];
    }
    
    
    int triplet_num_per_thread = triplet.size() / thread_num;
    for (int i = 0; i < thread_num - 1; i++) {
        threads_args[i].triplet_num = triplet_num_per_thread;
    }
    offset = triplet_num_per_thread * (thread_num - 1);
    int last_thread_triplet_num = triplet.size() - offset;
    threads_args[thread_num - 1].triplet_num = last_thread_triplet_num;

    for (int i = 0; i < thread_num - 1; i++) {
        for (int j = 0; j < triplet_num_per_thread; j++) {
            threads_args[i].thread_triplet.push_back(triplet[i * triplet_num_per_thread + j]);
        }
    }
    for (int i = 0; i < last_thread_triplet_num; i++) {
        threads_args[thread_num - 1].thread_triplet.push_back(triplet[i + offset]);
    }
    /**********************/
    
    real cost_w, cost_r, countword;
    int work_iter = 0;
    int count_normalization = 0;
    while (work_iter < iter) {

        
        
        cost_w = 0;
        cost_r = 0;
        countword = 0;
        //training link multi-thread
        for (int i = 0; i < thread_num; i++) pthread_create(&pt[i], NULL, \
            train_model_thread, (void *)(threads_args + i));
        for (int i = 0; i < thread_num; i++) pthread_join(pt[i], NULL);

        for (int i = 0; i < thread_num; i++) {
            cost_w += threads_args[i].cost_w;
            cost_r += threads_args[i].cost_r;
            countword += threads_args[i].cost_num_w;
        }

        //normalization
        for (int i = 0; i < entry_size; ++i) {
            //normalization(&entry_vec[i * vector_dim], vector_dim);
        }
		
		//fix ill-defined object function by limit the value of each dimension. 
		for(int i = 0; i < entry_size; ++i) {
			for(int j = 0; j < vector_dim; ++j) {
				if(entry_vec[i * vector_dim + j] > 5) {
				 entry_vec[i * vector_dim + j]=5;
				 }
				if(entry_vec[i * vector_dim + j] < -5) {
				entry_vec[i * vector_dim + j]=-5;
				}
			}
		}
		
        count_normalization++;
        //if(count_normalization%50==0) {
        //    for (int i = 0; i < word_size; ++i) {
        //        normalization(&word_vec[i * vector_dim], vector_dim);
        //    }
        //}
        
        std::cout << "iter: " << work_iter << "\tcost_w: " << cost_w / countword  << "\tcost_r:" <<cost_r / triplet.size() << std::endl;
        
        for (int i = 0; i < thread_num; i++) {
            threads_args[i].cost_w = 0;
            threads_args[i].cost_r = 0;
            threads_args[i].cost_num_w = 0;
        }
        //if(learn_pv == true || !strcmp(run_type,"fast_tune"))
           	if(!strcmp(run_type,"se_euler_word2vec_init") || !strcmp(run_type,"se_euler"))
				test_similarity_euler_per_iter(work_iter);
			else
				test_similarity_per_iter(work_iter);
			//test_wordsimilarity_per_iter(work_iter);
        /*if(learn_relation == true && work_iter%500 == 499){
			if(!strcmp(run_type,"se_euler_word2vec_init") || !strcmp(run_type,"se_euler"))
				test_similarity_euler_per_iter(work_iter);
			else
				test_similarity_per_iter(work_iter);
			
			//test_wordsimilarity_per_iter(work_iter);
            test_relation_per_iter(work_iter);
			char outputfile[128];
            sprintf(outputfile, "%s/vector_%d", model_dir, work_iter);
			output_embedding(outputfile,run_type);
		}*/
        work_iter++;
    }
    char outputfile[128];
    sprintf(outputfile, "%s/vector", model_dir);
    output_embedding(outputfile,run_type);
    topN(50);//This can be changed
}

void train_model() {
    init_vector();
    for (int i = 0; i < entry_size; i++) {
            shuffle_vec.push_back(i);
    }
    std::vector<int> local_shuffle_vec(shuffle_vec);
    int work_iter = 0;
    real cost_w, countword;
    
    // load test file
    load_similarity_test_file(similarity_test_file);
    load_relation_test_file(relation_test_file);
    //std::cout<<"here\n" <<std::flush;
    int count_normalization = 0;
    while (work_iter < iter) {
        char outputfile[50];
        sprintf(outputfile, "%s/vector_%d", model_dir, work_iter);
        
        cost_w = 0;
        countword = 0;
        //std::random_shuffle(local_shuffle_vec.begin(), local_shuffle_vec.end());
        //training word
        if(learn_pv == true) {
            for (unsigned int i = 0; i < local_shuffle_vec.size(); i++) { 
                update_embedding_paragraph(local_shuffle_vec[i], cost_w, countword);
            }
        }

        //normalization
        for (int i = 0; i < entry_size; ++i) {
            normalization(&entry_vec[i * vector_dim], vector_dim);
        }
        count_normalization++;
        if(count_normalization%50==0) {
            for (int i = 0; i < entry_size; ++i) {
            normalization(&word_vec[i * vector_dim], vector_dim);
            }
            
        }
        output_embedding(outputfile,run_type);
        test_similarity_per_iter(work_iter); 
        work_iter++;

        std::cout << "iter: " << work_iter << "\tcost_w: " << cost_w / countword << std::endl;
    
    }
    topN(50);//This can be changed
}

void load_similarity_modelfile(const char *model_file) {
	std::string line;
	std::vector<std::string> l;
	long long hash;
	
	std::ifstream input(model_file);
	getline(input, line);
	while(getline(input,line)) {
        l.clear();
        split(line, " ", l);
        hash = search_entry(l[0].c_str());
        int entry_name_hash = -1;
        //std::cout<<entry_name<<" "<<hash<<std::endl;
        if (-1 == hash) {
            entry_name_hash = get_insert_entry_hash(l[0].c_str());
            // save entity name to entry array
            entry_array[entry_size].entry_name = (char *)calloc(l[0].length() + 1, sizeof(char));
            strcpy(entry_array[entry_size].entry_name, l[0].c_str());
            entry_array[entry_size].entry_name[l[0].size()] = '\0';
            entry_hash[entry_name_hash] = entry_size;
            entry_size++;
            if (entry_size % 1000 == 0) std::cout << "entry size: " << entry_size << std::endl;
        }
    } 
	input.close();
    input.clear();
	
    input.open(model_file);
    getline(input, line);
	l.clear();
    split(line, " ", l);
    vector_dim = atoi(l[2].c_str());
	//std::cout<<atoi(l[2].c_str())<<std::endl;
    entry_vec = new real [entry_size * vector_dim];
    for(int i = 0; i < entry_size; ++i) {
        getline(input, line);
        l.clear();
        split(line, " ", l);
        hash = search_entry(l[0].c_str());
        for (int j = 0; j < vector_dim; ++j) {
			entry_vec[entry_hash[hash] * vector_dim + j] = atof(l[j + 1].c_str());
			//std::cout<<entry_vec[entry_hash[hash] * vector_dim + j]<<" "<<atof(l[j + 1].c_str())<<" ";
		}
		//std::cout<<std::endl;
    } 
    
    input.close();
    input.clear();
}
real maxcount = -1;
real mincount = 1000000000;
real var_word_sim=0;
real var_ent_sim=0;
real mean_word_sim=0;
real mean_ent_sim=0;
void load_similarity_modelfile_combine(const char *model_file_word,const char *model_file_pv) {
	std::string line;
	std::vector<std::string> l;
	long long hash;
	
	std::ifstream input(model_file_word);
	getline(input, line);

	while(getline(input,line)) {
        l.clear();
        split(line, " ", l);
        hash = search_word(l[0].c_str());
        int entry_name_hash = -1;
        //std::cout<<entry_name<<" "<<hash<<std::endl;
        if (-1 == hash) {
            entry_name_hash = get_insert_word_hash(l[0].c_str());
            // save entity name to entry array
            word_array[word_size].word = (char *)calloc(l[0].length() + 1, sizeof(char));
            strcpy(word_array[word_size].word, l[0].c_str());
            word_array[word_size].word[l[0].size()] = '\0';
			word_array[word_size].count = atoi(l[1].c_str());
			if(word_array[word_size].count < mincount) mincount=word_array[word_size].count;
			if(word_array[word_size].count > maxcount) maxcount=word_array[word_size].count;
            word_hash[entry_name_hash] = word_size;
            word_size++;
            if (word_size % 1000 == 0) std::cout << "word size: " << word_size << std::endl;
        }
    } 
	input.close();
    input.clear();
	
	input.open(model_file_pv);
	getline(input, line);
	while(getline(input,line)) {
        l.clear();
        split(line, " ", l);
        hash = search_word(l[0].c_str());
		//std::cout<<hash<<std::endl;
        int entry_name_hash = -1;
        //std::cout<<entry_name<<" "<<hash<<std::endl;
        if (-1 == hash) {
            entry_name_hash = get_insert_word_hash(l[0].c_str());
            // save entity name to entry array
            word_array[word_size].word = (char *)calloc(l[0].length() + 1, sizeof(char));
            strcpy(word_array[word_size].word, l[0].c_str());
            word_array[word_size].word[l[0].size()] = '\0';
			word_array[word_size].count = 0;
            word_hash[entry_name_hash] = word_size;
            word_size++;
            if (word_size % 1000 == 0) std::cout << "word size: " << word_size << std::endl;
        }
    } 
	input.close();
    input.clear();
	
	
    input.open(model_file_word);
    getline(input, line);
	l.clear();
    split(line, " ", l);
    vector_dim = atoi(l[2].c_str());
	//std::cout<<atoi(l[2].c_str())<<std::endl;
    word_vec = (real *)calloc(word_size * vector_dim, sizeof(real));
	memset(word_vec,100,sizeof(real) * word_size * vector_dim );
    while(getline(input, line)) {
        l.clear();
        split(line, " ", l);
        hash = search_word(l[0].c_str());
        for (int j = 0; j < vector_dim; ++j) {
			word_vec[word_hash[hash] * vector_dim + j] = atof(l[j + 2].c_str());
			//std::cout<<entry_vec[entry_hash[hash] * vector_dim + j]<<" "<<atof(l[j + 1].c_str())<<" ";
		}

		//std::cout<<std::endl;
    } 
	
	real maxlength=-1;
	for(int i = 0; i < word_size; ++i) {
		real sim = multiply(word_vec + i * vector_dim, word_vec + i * vector_dim, vector_dim);
		if (sim > maxlength) maxlength = sim;
	}

	
	for(int i = 0; i < word_size; ++i) {
		for(int j = 0; j < word_size; ++j){
			real sim = multiply(word_vec + i * vector_dim, word_vec + j * vector_dim, vector_dim);
			
			mean_word_sim += sim;
		}
	}
	mean_word_sim /= word_size * word_size;
	
	for(int i = 0; i < word_size; ++i) {
		for(int j = 0; j < word_size; ++j){
			real sim = multiply(word_vec + i * vector_dim, word_vec + j * vector_dim, vector_dim);
			
			var_word_sim+=(sim-mean_word_sim) * (sim-mean_word_sim);
		}
	}
	
	var_word_sim/=word_size * word_size;
	var_word_sim = sqrt(var_word_sim);
	
	std::cout<<"var_word_sim="<<var_word_sim << " mean_word_sim"<<mean_word_sim<<std::endl;
    
    input.close();
    input.clear();
	///////////////////////////////////////////
	
	
    input.open(model_file_pv);
    getline(input, line);
	l.clear();
    split(line, " ", l);
    vector_dim = atoi(l[2].c_str());
	//std::cout<<atoi(l[2].c_str())<<std::endl;
    entry_vec = (real *)calloc(word_size * vector_dim, sizeof(real));
	memset(entry_vec,100,sizeof(real) * word_size * vector_dim );
    while(getline(input, line)) {
        l.clear();
        split(line, " ", l);
        hash = search_word(l[0].c_str());
        for (int j = 0; j < vector_dim; ++j) {
			entry_vec[word_hash[hash] * vector_dim + j] = atof(l[j + 1].c_str());
			//std::cout<<entry_vec[entry_hash[hash] * vector_dim + j]<<" "<<atof(l[j + 1].c_str())<<" ";
		}
		//std::cout<<std::endl;
    } 
   for(int i = 0; i < word_size; ++i) {
		for(int j = 0; j < word_size; ++j){
			real sim = multiply(entry_vec + i * vector_dim, entry_vec + j * vector_dim, vector_dim);
			
			mean_ent_sim += sim;
		}
	}
	mean_ent_sim /= word_size * word_size;
	
	for(int i = 0; i < word_size; ++i) {
		for(int j = 0; j < word_size; ++j){
			real sim = multiply(entry_vec + i * vector_dim, entry_vec + j * vector_dim, vector_dim);
			
			var_ent_sim+=(sim-mean_ent_sim) * (sim-mean_ent_sim);
		}
	}
	
	var_ent_sim/=word_size * word_size;
	var_ent_sim = sqrt(var_ent_sim);
	
	std::cout<<"var_ent_sim="<<var_ent_sim<<" mean_ent_sim="<<mean_ent_sim<<std::endl;
    input.close();
    input.clear();

}


void load_relation_modelfile(const char *model_file) {
    std::ifstream input(model_file);
    std::string line;
    getline(input, line);
    std::vector<std::string> l;
    split(line, " ", l);
    long long hash;
    if (!strcmp(l[0].c_str(),"se") || !strcmp(l[0].c_str(),"se-pv")) {
        entry_size = atoi(l[1].c_str());
        vector_dim = atoi(l[2].c_str());
        rel_size = atoi(l[3].c_str());
        entry_vec = new real [entry_size * vector_dim];
        for(int i = 0; i < entry_size; ++i) {
            getline(input, line);
            l.clear();
            split(line, " ", l);
            hash = get_insert_entry_hash(l[0].c_str());
            entry_hash[hash] = i;
            entry_array[i].entry_name = (char *)calloc(l[0].length() + 1, sizeof(char));
            strcpy(entry_array[i].entry_name, l[0].c_str());
            entry_array[i].entry_name[l[0].size()] = '\0';

            for (int j = 0; j < vector_dim; ++j) entry_vec[i * vector_dim + j] = atof(l[j + 1].c_str());

        } 
        for(int i = 0; i < rel_size; ++i) {
            getline(input, line);
            l.clear();
            split(line, " ", l);
            rel2id.insert(std::pair<std::string,int>(l[0],i));
            id2rel.insert(std::pair<int,std::string>(i,l[0]));
        }
    } else if (!strcmp(l[0].c_str(),"transe") || !strcmp(l[0].c_str(),"transe-pv")) {
        entry_size = atoi(l[1].c_str());
        vector_dim = atoi(l[2].c_str());
        rel_size = atoi(l[3].c_str());
        
        entry_vec = new real [entry_size * vector_dim];
        relation_vec = new real [rel_size * vector_dim];
        for(int i = 0; i < entry_size; ++i) {
            getline(input, line);
            l.clear();
            split(line, " ", l);
            hash = get_insert_entry_hash(l[0].c_str());
            entry_hash[hash] = i;
            entry_array[i].entry_name = (char *)calloc(l[0].length() + 1, sizeof(char));
            strcpy(entry_array[i].entry_name, l[0].c_str());
            entry_array[i].entry_name[l[0].size()] = '\0';
            for (int j = 0; j < vector_dim; ++j) entry_vec[i * vector_dim + j] = atof(l[j + 1].c_str());
        }
        for(int i = 0; i < rel_size; ++i) {
            getline(input, line);
            l.clear();
            split(line, " ", l);
            rel2id.insert(std::pair<std::string,int>(l[0],i));
            id2rel.insert(std::pair<int,std::string>(i,l[0]));
            for (int j = 0; j < vector_dim; ++j) relation_vec[i * vector_dim + j] = atof(l[j + 1].c_str());
        }
    } else if (!strcmp(l[0].c_str(),"transr") || !strcmp(l[0].c_str(),"transr-pv")) {
        entry_size = atoi(l[1].c_str());
        vector_dim = atoi(l[2].c_str());
        rel_size = atoi(l[3].c_str());
        
        entry_vec = new real [entry_size * vector_dim];
        relation_vec = new real [rel_size * vector_dim];
        transform = new real [rel_size * vector_dim * vector_dim];
        for(int i = 0; i < entry_size; ++i) {
            getline(input, line);
            l.clear();
            split(line, " ", l);
            hash = get_insert_entry_hash(l[0].c_str());
            entry_hash[hash] = i;
            entry_array[i].entry_name = (char *)calloc(l[0].length() + 1, sizeof(char));
            strcpy(entry_array[i].entry_name, l[0].c_str());
            entry_array[i].entry_name[l[0].size()] = '\0';
            for (int j = 0; j < vector_dim; ++j) entry_vec[i * vector_dim + j] = atof(l[j + 1].c_str());
        }
        for(int i = 0; i < rel_size; ++i) {
            getline(input, line);
            l.clear();
            split(line, " ", l);
            rel2id.insert(std::pair<std::string,int>(l[0],i));
            id2rel.insert(std::pair<int,std::string>(i,l[0]));
            for (int j = 0; j < vector_dim; ++j) relation_vec[i * vector_dim + j] = atof(l[j + 1].c_str());
        }
        for(int i = 0; i < rel_size; ++i) {
            getline(input, line);
            l.clear();
            split(line, " ", l);
            for (int j = 0; j < vector_dim; ++j) for(int k = 0; k < vector_dim; ++k)transform[i * vector_dim * vector_dim + j * vector_dim + k]\
                                                                                    = atof(l[j * vector_dim + k +1].c_str());
        }
    }

    input.close();
    input.clear();
}


void test_model_similarity() {
    // Spearman rank-order correlation coefficient
    std::vector<Id_Score_Rank> score_rank;
    std::vector<Id_Score_Rank> score_rank_answer;
    for (unsigned int i = 0; i < test_array_sim.size(); ++i) {
        real maxcosine=-10;
        for (unsigned int lefti = 0; lefti < test_array_sim[i].leftindex.size(); ++lefti) {
            for (unsigned int righti = 0; righti < test_array_sim[i].rightindex.size(); ++righti) {
				//std::cout<<entry_array[test_array_sim[i].leftindex[lefti]].entry_name<<" "<<entry_array[test_array_sim[i].rightindex[righti]].entry_name<<std::endl;
				for(int j = 0; j < vector_dim; ++j)
				{
					//std::cout<<entry_vec[test_array_sim[i].leftindex[lefti] * vector_dim + j]<< " ";
				}
				//std::cout<<std::endl;
				for(int j = 0; j < vector_dim; ++j)
				{
					//std::cout<<entry_vec[test_array_sim[i].rightindex[righti] * vector_dim + j]<< " ";
				}
				//std::cout<<std::endl;
                real score = multiply(&entry_vec[test_array_sim[i].leftindex[lefti] * vector_dim], \
                            &entry_vec[test_array_sim[i].rightindex[righti] * vector_dim], vector_dim);
                if (score > maxcosine) {
                    maxcosine = score;
                }
            }
        }

        Id_Score_Rank isr = {i, maxcosine, 0};
        Id_Score_Rank isr_answer = {i, test_array_sim[i].score, 0};
        score_rank.push_back(isr);
        score_rank_answer.push_back(isr_answer);
    }
    sort(score_rank.begin(), score_rank.end(), compareScore);
    sort(score_rank_answer.begin(), score_rank_answer.end(), compareScore);

    for (unsigned int i = 0; i < score_rank.size(); ++i) {
        score_rank[i].rank = i;
        score_rank_answer[i].rank = i;
    }
	
    sort(score_rank.begin(),score_rank.end(),compareId);
    sort(score_rank_answer.begin(),score_rank_answer.end(),compareId);

    
    real sum_delta=0;
    for (unsigned int i = 0; i < test_array_sim.size(); ++i) {
        std::cout << entry_array[test_array_sim[i].leftindex[0]].entry_name << '\t' \
            << entry_array[test_array_sim[i].rightindex[0]].entry_name << '\t' \
            << score_rank[i].rank << '\t' << score_rank_answer[i].rank << '\t' \
            << test_array_sim[i].score << std::endl;
        sum_delta += pow(score_rank[i].rank - score_rank_answer[i].rank, 2);
    }

    real coefficient = 1.0 - 6.0 * sum_delta / (real)test_array_sim.size() / (real)(pow(test_array_sim.size(),2) - 1);
    std::cout << "Spearman rank-order correlation coefficient: " << coefficient << std::endl;
    
    //Pearson correlation coefficient
    real innerproduct_sum=0;
    real predict_sum=0;
    real answer_sum=0;
    real predict_pow_sum=0;
    real answer_pow_sum=0;
    for (unsigned int i=0;i<score_rank.size();++i) {
        predict_sum+=score_rank[i].score;
        predict_pow_sum+=pow(score_rank[i].score, 2);
        answer_sum+=score_rank_answer[i].score;
        answer_pow_sum+=pow(score_rank_answer[i].score, 2);
        innerproduct_sum+=score_rank[i].score * score_rank_answer[i].score;
    }
    coefficient = (score_rank.size() * innerproduct_sum - predict_sum * answer_sum) / \
                    sqrt(score_rank.size() * predict_pow_sum - pow(predict_sum, 2)) / \
                    sqrt(score_rank.size() * answer_pow_sum - pow(answer_sum, 2));
    
    std::cout<<"The Pearson correlation coefficient between prediction and answer is around "<<coefficient<<std::endl;
    delete [] entry_vec;
}
real count_min_2, count_max_2_minus_min_2;



void test_model_similarity_combine() {
	//real count_min_2 = mincount * mincount;
	//real count_max_2_minus_min_2 = maxcount * maxcount - mincount * mincount;
    // Spearman rank-order correlation coefficient
    std::vector<Id_Score_Rank> score_rank;
    std::vector<Id_Score_Rank> score_rank_answer;
    for (unsigned int i = 0; i < test_array_sim.size(); ++i) {
        real maxcosine=-10;
		int maxleft=-1;
		int maxright=-1;
		real alphaa=1;
        for (unsigned int lefti = 0; lefti < test_array_sim[i].leftindex.size(); ++lefti) {
            for (unsigned int righti = 0; righti < test_array_sim[i].rightindex.size(); ++righti) {
				real leftcount=word_array[test_array_sim[i].leftindex[lefti]].count;
				real rightcount=word_array[test_array_sim[i].rightindex[righti]].count;
				//real alpha = (sqrt(leftcount * rightcount) - mincount )/ (maxcount-mincount);
                real alpha = (leftcount < 400 && rightcount < 400) ? 0 : 1;
				//real alpha = (leftcount * rightcount < 55000) ? 0 : 1;
				alpha=0;;
				//if(alpha == 1)std::cout<<word_array[test_array_sim[i].leftindex[lefti]].word<< " "<< word_array[test_array_sim[i].rightindex[righti]].word<<std::endl;
				/*real score = alpha * sin( multiply(&word_vec[test_array_sim[i].leftindex[lefti] * vector_dim], \
                            &word_vec[test_array_sim[i].rightindex[righti] * vector_dim], vector_dim) / max_word_sim * PI / 2.0) \
							 + (1-alpha) * multiply(&entry_vec[test_array_sim[i].leftindex[lefti] * vector_dim], \
                            &entry_vec[test_array_sim[i].rightindex[righti] * vector_dim], vector_dim); */
				real score = alpha * ( multiply(&word_vec[test_array_sim[i].leftindex[lefti] * vector_dim], \
                            &word_vec[test_array_sim[i].rightindex[righti] * vector_dim], vector_dim)- mean_word_sim ) / var_word_sim  \
							 + (1-alpha) * ( multiply(&entry_vec[test_array_sim[i].leftindex[lefti] * vector_dim], \
                            &entry_vec[test_array_sim[i].rightindex[righti] * vector_dim], vector_dim)- mean_ent_sim ) / var_ent_sim - (1-alpha) * 0;
                if (score > maxcosine) {
                    maxcosine = score;
					maxleft = test_array_sim[i].leftindex[lefti];
					maxright= test_array_sim[i].rightindex[righti];
					alphaa=alpha;
                }
            }
        }
		if(alphaa==0)std::cout<<word_array[maxleft].word<<" "<<word_array[maxright].word<<" "<<maxcosine<<std::endl;
        Id_Score_Rank isr = {i, maxcosine, 0};
        Id_Score_Rank isr_answer = {i, test_array_sim[i].score, 0};
        score_rank.push_back(isr);
        score_rank_answer.push_back(isr_answer);
    }
    sort(score_rank.begin(), score_rank.end(), compareScore);
    sort(score_rank_answer.begin(), score_rank_answer.end(), compareScore);
	std::cout<<"here"<<std::endl;
    for (unsigned int i = 0; i < score_rank.size(); ++i) {
        score_rank[i].rank = i;
        score_rank_answer[i].rank = i;
    }
	
    sort(score_rank.begin(),score_rank.end(),compareId);
    sort(score_rank_answer.begin(),score_rank_answer.end(),compareId);
	std::cout<<"here2"<<std::endl;
    
    real sum_delta=0;
    for (unsigned int i = 0; i < test_array_sim.size(); ++i) {
        std::cout << word_array[test_array_sim[i].leftindex[0]].word << '\t' \
            << word_array[test_array_sim[i].rightindex[0]].word << '\t' \
            << score_rank[i].rank << '\t' << score_rank_answer[i].rank << '\t' \
            << test_array_sim[i].score << std::endl;
        sum_delta += pow(score_rank[i].rank - score_rank_answer[i].rank, 2);
    }
	std::cout<<"here3"<<std::endl;
    real coefficient = 1.0 - 6.0 * sum_delta / (real)test_array_sim.size() / (real)(pow(test_array_sim.size(),2) - 1);
    std::cout << "Spearman rank-order correlation coefficient: " << coefficient << std::endl;
    
    //Pearson correlation coefficient
    real innerproduct_sum=0;
    real predict_sum=0;
    real answer_sum=0;
    real predict_pow_sum=0;
    real answer_pow_sum=0;
    for (unsigned int i=0;i<score_rank.size();++i) {
        predict_sum+=score_rank[i].score;
        predict_pow_sum+=pow(score_rank[i].score, 2);
        answer_sum+=score_rank_answer[i].score;
        answer_pow_sum+=pow(score_rank_answer[i].score, 2);
        innerproduct_sum+=score_rank[i].score * score_rank_answer[i].score;
    }
    coefficient = (score_rank.size() * innerproduct_sum - predict_sum * answer_sum) / \
                    sqrt(score_rank.size() * predict_pow_sum - pow(predict_sum, 2)) / \
                    sqrt(score_rank.size() * answer_pow_sum - pow(answer_sum, 2));
    
    std::cout<<"The Pearson correlation coefficient between prediction and answer is around "<<coefficient<<std::endl;
    delete [] entry_vec;
}

void test_model_similarity_euler() {
    // Spearman rank-order correlation coefficient
    std::vector<Id_Score_Rank> score_rank;
    std::vector<Id_Score_Rank> score_rank_answer;
    for (unsigned int i = 0; i < test_array_sim.size(); ++i) {
        real maxcosine=-10;
        for (unsigned int lefti = 0; lefti < test_array_sim[i].leftindex.size(); ++lefti) {
            for (unsigned int righti = 0; righti < test_array_sim[i].rightindex.size(); ++righti) {
                real score = 0;
				for(int k = 0; k < vector_dim; ++k) 
				score += -fabs(entry_vec[test_array_sim[i].leftindex[lefti] * vector_dim + k] - entry_vec[test_array_sim[i].rightindex[righti] * vector_dim + k]);
                if (score > maxcosine) {
                    maxcosine = score;
                }
            }
        }

        Id_Score_Rank isr = {i, maxcosine, 0};
        Id_Score_Rank isr_answer = {i, test_array_sim[i].score, 0};
        score_rank.push_back(isr);
        score_rank_answer.push_back(isr_answer);
    }
    sort(score_rank.begin(), score_rank.end(), compareScore);
    sort(score_rank_answer.begin(), score_rank_answer.end(), compareScore);

    for (unsigned int i = 0; i < score_rank.size(); ++i) {
        score_rank[i].rank = i;
        score_rank_answer[i].rank = i;
    }

    sort(score_rank.begin(),score_rank.end(),compareId);
    sort(score_rank_answer.begin(),score_rank_answer.end(),compareId);

    
    real sum_delta=0;
    for (unsigned int i = 0; i < test_array_sim.size(); ++i) {
        std::cout << entry_array[test_array_sim[i].leftindex[0]].entry_name << '\t' \
            << entry_array[test_array_sim[i].rightindex[0]].entry_name << '\t' \
            << score_rank[i].rank << '\t' << score_rank_answer[i].rank << '\t' \
            << test_array_sim[i].score << std::endl;
        sum_delta += pow(score_rank[i].rank - score_rank_answer[i].rank, 2);
    }

    real coefficient = 1.0 - 6.0 * sum_delta / (real)test_array_sim.size() / (real)(pow(test_array_sim.size(),2) - 1);
    std::cout << "Spearman rank-order correlation coefficient: " << coefficient << std::endl;
    
    //Pearson correlation coefficient
    real innerproduct_sum=0;
    real predict_sum=0;
    real answer_sum=0;
    real predict_pow_sum=0;
    real answer_pow_sum=0;
    for (unsigned int i=0;i<score_rank.size();++i) {
        predict_sum+=score_rank[i].score;
        predict_pow_sum+=pow(score_rank[i].score, 2);
        answer_sum+=score_rank_answer[i].score;
        answer_pow_sum+=pow(score_rank_answer[i].score, 2);
        innerproduct_sum+=score_rank[i].score * score_rank_answer[i].score;
    }
    coefficient = (score_rank.size() * innerproduct_sum - predict_sum * answer_sum) / \
                    sqrt(score_rank.size() * predict_pow_sum - pow(predict_sum, 2)) / \
                    sqrt(score_rank.size() * answer_pow_sum - pow(answer_sum, 2));
    
    std::cout<<"The Pearson correlation coefficient between prediction and answer is around "<<coefficient<<std::endl;
    delete [] entry_vec;
}

void test_model_relation() {
    real top10hit_left = 0;
    real top10hit_right = 0;
    real *midres = new real [vector_dim];
    real *cosine = (real*)calloc(entry_size,sizeof(real));
    std::vector<int> res_ent;
    for(unsigned int i = 0;i < testtriple.size(); ++i)
    {
        int left_id = testtriple[i].lid;
        int right_id = testtriple[i].rid;
        int rel_id = testtriple[i].relid;
        int score =100;
        memset(cosine,0,sizeof(real) * entry_size);
        ////////////////////////////predict tail
        if(!strcmp(run_type,"test-relation-se")) {
            for(int j = 0; j < entry_size; ++j)
            {
                cosine[j] = -multiply(entry_vec + left_id * vector_dim, entry_vec + j * vector_dim, vector_dim);
            }

        } else if(!strcmp(run_type,"test-relation-unstructure_euler")) {
            for(int j = 0;j < entry_size; ++j)
            {
                //cosine[j] = -multiply(midres,entry_vec + j * vector_dim, vector_dim);
				for(int k = 0; k < vector_dim; ++k) {
					cosine[j] += fabs(entry_vec[left_id * vector_dim + k] - entry_vec[j * vector_dim + k]);
				}
            }
        } else if (!strcmp(run_type,"test-relation-transe")) {
            for(int j = 0; j < vector_dim; ++j) midres[j] = entry_vec[left_id * vector_dim + j] + relation_vec[rel_id * vector_dim + j];
            for(int j = 0;j < entry_size; ++j)
            {
                //cosine[j] = -multiply(midres,entry_vec + j * vector_dim, vector_dim);
				for(int k = 0; k < vector_dim; ++k) {
					cosine[j] += fabs(midres[k] - entry_vec[j * vector_dim + k]);
				}
				
            }
        } else if (!strcmp(run_type,"test-relation-transr")) {
            for(int j = 0; j < vector_dim; ++j)
                midres[j] = multiply(transform + rel_id * vector_dim * vector_dim + vector_dim * j, entry_vec + left_id * vector_dim, vector_dim)\
                +  relation_vec[rel_id * vector_dim + j];
            for(int j = 0; j < entry_size; ++j) {
                real mid = multiply(transform + rel_id * vector_dim * vector_dim + vector_dim * j, entry_vec + j * vector_dim, vector_dim);
                for(int k = 0; k < vector_dim; ++k)
                    cosine[j] += midres[k] * mid;
                cosine[j] = -cosine[j];
            }
            
        }
        
        res_ent = get_similar_entry(cosine, entry_size, 10); 
        for(int j=0;j<10;++j)
        {
            if(res_ent[j]==right_id)
            {
                    score=j+1;
                    break;
            }
        }
        
        if(score<=10)top10hit_right+=1;
        
        res_ent.clear();
        std::cout<<entry_array[right_id].entry_name<<" "<<score<<" ";
        //////////////////////////predict head
        score=100;
        memset(cosine,0,sizeof(real) * entry_size);
        if(!strcmp(run_type,"test-relation-se")) {
            for(int j = 0; j < entry_size; ++j)
            {
                cosine[j] = -multiply(entry_vec + right_id * vector_dim, entry_vec + j * vector_dim, vector_dim);
            }
        } else if(!strcmp(run_type,"test-relation-unstructure_euler")) {
            for(int j = 0;j < entry_size; ++j)
            {
                //cosine[j] = -multiply(midres,entry_vec + j * vector_dim, vector_dim);
				for(int k = 0; k < vector_dim; ++k) {
					cosine[j] += fabs(entry_vec[j * vector_dim + k] - entry_vec[right_id * vector_dim + k]);
				}
            }
        } else if (!strcmp(run_type,"test-relation-transe")) {
            for (int k = 0; k < vector_dim; ++k) midres[k] = relation_vec[rel_id * vector_dim + k] - entry_vec[right_id * vector_dim + k];
            for(int j = 0; j < entry_size; ++j)
            {
				for(int k = 0; k < vector_dim; ++k)
					cosine[j] += fabs(entry_vec[j * vector_dim + k] + midres[k]);
            }
        } else if (!strcmp(run_type,"test-relation-transr")) {
            for(int j = 0; j < vector_dim; ++j)
                midres[j] = multiply(transform + rel_id * vector_dim * vector_dim + vector_dim * j, entry_vec + right_id * vector_dim, vector_dim)\
                -  relation_vec[rel_id * vector_dim + j];
            for(int j = 0; j < entry_size; ++j) {
                real mid = multiply(transform + rel_id * vector_dim * vector_dim + vector_dim * j, entry_vec + j * vector_dim, vector_dim);
                for(int k = 0; k < vector_dim; ++k)
                    cosine[j] += midres[k] * mid;
                cosine[j] = -cosine[j];
            }
        }
        res_ent = get_similar_entry(cosine, entry_size, 10);
        
        for(int j=0;j<10;++j)
        {
            if(res_ent[j]==left_id)
            {
                    score=j+1;
                    break;
            }
        }

        if(score<=10)top10hit_left+=1;
        res_ent.clear();
        std::cout<<entry_array[left_id].entry_name<<" "<<score<<std::endl;
        
    }
    delete [] midres;
    delete [] cosine;
    top10hit_left/=testtriple.size();
    top10hit_right/=testtriple.size();
    std::cout<<"test set: top10hit_right rate:"<<top10hit_right<<std::endl;
    std::cout<<"test set: top10hit_left rate:"<<top10hit_left<<std::endl;
    std::cout<<"test set: top10hit_average rate:"<<(top10hit_left+top10hit_right)/2<<std::endl;
    
}

int arg_pos(const char *arg, int argc, char **argv) {
    int i = 1;
    for (; i < argc; i++) {
        if (!strcmp(arg, argv[i])) {
            if (i == argc - 1) {
                std::cerr << "argument missing for: " << arg << std::endl;
                exit(1);
            }
            return i;
        }
    }
    return -1;
}



int main(int argc, char *argv[]) {
    int i;
    if (argc == 1) {
        std::cout << "KNOWLEDGE VECTOR estimation toolkit v0.1\n\n";
        std::cout << "Options:\n";
        std::cout << "Parameters for training:\n";
        std::cout << "\t-type <Option>\n";
        std::cout << "\t\ttest-similarity  test-similarity-combine pv se se_euler se_word2vec_init se_euler_word2vec_init se-pv fast_tune pv_word2vec_init pv_word2vec_init_both_pv_and_word2vec  pv_word2vec_average\n";
		std::cout << "\t-pv_input <file>\n";
        std::cout << "\t\tUse text data <file> to train the pv-model\n";
        std::cout << "\t-triplet_input <file>\n";
        std::cout << "\t\tUse triplet data <file> to train the relation graph model\n";
        std::cout << "\t-model_output <directory>\n";
        std::cout << "\t\toutput directory of model, directory should exist;\n";
		std::cout << "\t-word2vec_input <file>\n";
		std::cout << "\t\tinput file of word2vec to init word vector;\n";
		std::cout << "\t-model_input_pv <file>\n";
		std::cout << "\t\tinput file of pv to init pv;\n";
		std::cout << "\t-model_input_word <file>\n";
		std::cout << "\t\tinput file of word2vec to init pv;\n";
        std::cout << "\t-sim_test_input <file>\n";
        std::cout << "\t\tinput file of test dataset for similarity\n";
        std::cout << "\t-rel_test_input <file>\n";
        std::cout << "\t\tinput file of test dataset for relation prediction\n";
        std::cout << "\t-topn_output <file>\n";
        std::cout << "\t\twhen training finished ,program will output a file containing top20 similar list for each entry\n";
        std::cout << "\t-threads <int>\n";
        std::cout << "\t\tUse <int> threads (default 1), when set a higher number, please use -mtrain\n";
        std::cout << "\t-iter <int>\n";
        std::cout << "\t\tRun more training iterations (default 100)\n";
        std::cout << "\t-dim <int>\n";
        std::cout << "\t\tDimension for the knowledge vector (default 40)\n";
        std::cout << "\t-learn_rate_r <float>\n";
        std::cout << "\t\tLearning rate for relation training on entry vector";
        std::cout << "\t-learn_rate_r_rel <float>\n";
        std::cout << "\t\tLearning rate for relation training on relation vector.";
        std::cout << "\t-learn_rate_pv <float>\n";
        std::cout << "\t\tLearning rate for pv training";
        std::cout << "\nExample:\n";
        std::cout << "./knowledge2vec -type se -triplet_input wordnet-mlj12-train.txt -model_output outputdata_unstructure "<<
                     "-rel_test_input wordnet-mlj12-valid.txt -threads 1 -iter 1000 -dim 50 -learn_rate_r 0.01 -learn_rate_r_rel 0.001 >log/log_wordnet_unst\n";
        std::cout << "./knowledge2vec -type pv -pv_input wordnet_gloss -model_output outputdata_pv "<<
                     "-sim_test_input 322.res -threads 1 -iter 1000 -dim 50 -learn_rate_pv 0.01 >log/log_wordnet_pv\n";
        std::cout << "./knowledge2vec -type transe-pv -pv_input wordnet_gloss -triplet_input wordnet-mlj12-train.txt -model_output outputdata_transe_pv "<<
                     "-sim_test_input 322.res -rel_test_input wordnet-mlj12-valid.txt -threads 1 -iter 1000 -dim 50 -learn_rate_pv 0.01 "<<
                     "-learn_rate_r 0.01 -learn_rate_r_rel 0.001 >log/log_wordnet_transe_pv\n";
        std::cout << "./knowledge2vec -type test-similarity -model_input outputdata_unstructure/vector -sim_test_input data/322.testset -dim 50\n";
        std::cout << "./knowledge2vec -type test-relation-transe -model_input outputdata_unstructure/vector  -rel_test_input data/wordnet-mlj12-test.txt -dim 50\n";

        return 0;
    }

    if ((i = arg_pos("-type", argc, argv)) > 0) {
        strcpy(run_type,argv[i + 1]);
    }
	if ((i = arg_pos("-word2vec_input", argc, argv)) > 0) {
        strcpy(wordvec_input_file, argv[i + 1]);
    }
    if ((i = arg_pos("-pv_input", argc, argv)) > 0) {
        strcpy(pv_input_file, argv[i + 1]);
    }
    if ((i = arg_pos("-triplet_input", argc, argv)) > 0) {
        strcpy(triplet_input_file, argv[i + 1]);
    }
    if ((i = arg_pos("-model_output",argc, argv)) > 0) {
        strcpy(model_dir,argv[i + 1]);
    }
	if ((i = arg_pos("-model_input_word",argc, argv)) > 0) {
        strcpy(model_file_word,argv[i + 1]);
    }
	if ((i = arg_pos("-model_input_pv",argc, argv)) > 0) {
        strcpy(model_file_pv,argv[i + 1]);
    }
    if ((i = arg_pos("-sim_test_input",argc, argv)) > 0) {
        strcpy(similarity_test_file,argv[i + 1]);
    }
    if ((i = arg_pos("-rel_test_input",argc, argv)) > 0) {
        strcpy(relation_test_file,argv[i + 1]);
    }
    if ((i = arg_pos("-threads", argc, argv)) > 0) {
        thread_num = atoi(argv[i + 1]);
    }
    if ((i = arg_pos("-iter", argc, argv)) > 0) {
        iter = atoi(argv[i + 1]);
    }
    if ((i = arg_pos("-dim",argc, argv)) > 0) {
        vector_dim = atoi(argv[i + 1]);
    }
    if ((i = arg_pos("-learn_rate_pv", argc, argv)) > 0) {
        learn_rate_pv = atof(argv[i + 1]);
    }
    if ((i = arg_pos("-learn_rate_r", argc, argv)) > 0) {
        learn_rate_r = atof(argv[i + 1]);
    }
    if ((i = arg_pos("-learn_rate_r_rel", argc, argv)) > 0) {
        learn_rate_r_rel = atof(argv[i + 1]);
    }
    if ((i = arg_pos("-topn_output", argc, argv)) > 0) {
        strcpy(topn_output, argv[i + 1]);
    }
	if ((i = arg_pos("-word_output", argc, argv)) > 0) {
        strcpy(wordvec_output_file, argv[i + 1]);
    }
    
    entry_array = (struct entry *)calloc(max_entry_size, sizeof(struct entry));
    entry_hash = (int *)malloc(entry_hash_size * sizeof(int)); // save the pos of each entry in entry array
    for (int i = 0; i < entry_hash_size; i++) entry_hash[i] = -1;
    
    word_array = (struct word_info *)calloc(max_word_size, sizeof(struct word_info));
    word_hash = (int *)malloc(entry_hash_size * sizeof(int));
    for (int i = 0; i < word_hash_size; i++) word_hash[i] = -1;

    exp_table = (real *)malloc((EXP_TABLE_SIZE + 1) * sizeof(real));
    for (int i = 0; i <= EXP_TABLE_SIZE; i++) {
        exp_table[i] = exp((i / (real)EXP_TABLE_SIZE * 2 - 1) * MAX_EXP);
    }

    //real average_freq=0;
    //for(unsigned int i = 0; i < shuffle_vec.size(); ++i) {
    //    average_freq += entry_array[shuffle_vec[i]].freq;
    //}
    //std::cout<<"average freq = "<<average_freq/shuffle_vec.size()<<std::endl;   
    
    
    if (!strcmp(run_type,"test-similarity")) {
            load_similarity_modelfile(model_file_pv);
            load_similarity_test_file(similarity_test_file);
            test_model_similarity();
    } else if (!strcmp(run_type,"test-similarity-combine")) {
            load_similarity_modelfile_combine(model_file_word,model_file_pv);
			std::cout<<"1"<<std::endl;
            load_similarity_test_file_combine(similarity_test_file);
			std::cout<<"2"<<std::endl;
            test_model_similarity_combine();
    } else if (!strcmp(run_type,"test-relation-se")) {
            load_relation_modelfile(model_file_pv);
            load_relation_test_file(relation_test_file);
            test_model_relation();
    } else if (!strcmp(run_type,"pv") ) { //after this, using fast_tune
			std::cout<<"1"<<std::endl;
			load_entry_paragraph(pv_input_file);
			std::cout<<"1"<<std::endl;
			learn_pv = true;
			init_vector();
			std::cout<<"2"<<std::endl;
			
			std::cout<<"3"<<std::endl;
            train_model_multithread();
    } else if (!strcmp(run_type,"se_word2vec_init")) {
            load_triplet(triplet_input_file);
            learn_relation = true;
			init_vector();
			load_word2vec_and_init_pv(model_file_word); 
            train_model_multithread();
    } else if (!strcmp(run_type,"se_euler_word2vec_init")) {
            load_triplet(triplet_input_file);
            learn_relation = true;
			init_vector();
			load_word2vec_and_init_pv(model_file_word); 
            train_model_multithread();
    } else if (!strcmp(run_type,"se")) {
            load_triplet(triplet_input_file);
            learn_relation = true;
			init_vector();
            train_model_multithread();
    } else if (!strcmp(run_type,"se_euler")) {
            load_triplet(triplet_input_file);
            learn_relation = true;
			init_vector();
            train_model_multithread();
    } else if (!strcmp(run_type,"transe_word2vec_init")) {
            load_triplet(triplet_input_file);
            learn_relation = true;
			init_vector();
			load_word2vec_and_init_pv(model_file_word); 
            train_model_multithread();
    } else if (!strcmp(run_type,"se-pv")) {
			load_entry_paragraph(pv_input_file);
            load_triplet(triplet_input_file);
            learn_pv = true;
            learn_relation = true;
			init_vector();
			load_word2vec_and_init_pv(model_file_word);
            train_model_multithread();
    } else if (!strcmp(run_type,"transe-pv")) {
			load_entry_paragraph(pv_input_file);
            load_triplet(triplet_input_file);
            learn_pv = true;
            learn_relation = true;
			init_vector();
			load_word2vec_and_init_pv(model_file_word);
            train_model_multithread();
    } else if (!strcmp(run_type,"fast_tune") ) {
			load_triplet(triplet_input_file);
            load_similarity_modelfile(model_file_pv);
			
            learn_relation = true;
            train_model_multithread();
    } else if (!strcmp(run_type,"pv_word2vec_init") ) { //after this, using fast_tune
			std::cout<<"1"<<std::endl;
			load_entry_paragraph(pv_input_file);
			std::cout<<"1"<<std::endl;
			learn_pv = true;
			init_vector();
			std::cout<<"2"<<std::endl;
			load_word2vec_and_init_pv(model_file_word);
			std::cout<<"3"<<std::endl;
            train_model_multithread();
    } else if (!strcmp(run_type,"pv_word2vec_init_both_pv_and_word2vec") ) { //after this, using fast_tune
			load_entry_paragraph(pv_input_file);
			learn_pv = true;
			init_vector();
			load_word2vec_and_init(wordvec_input_file);
			load_word2vec_and_init_pv(model_file_word);
            train_model_multithread();
    } else if (!strcmp(run_type,"pv_word2vec_average") ) {//after this, using fast_tune
            load_entry_paragraph(pv_input_file);
			
			load_word2vec_and_init(wordvec_input_file);
			average_word2vec_and_output();
			load_similarity_test_file(similarity_test_file);
			//load_similarity_test_file_word();
			std::cout<<"here4"<<std::endl;
			test_similarity_per_iter(0);
			
    }  else {
            std::cout << "error model type." << std::endl;
            exit(0);      
    }
    
    // TODO: free the allocated space
    return 0;
}
